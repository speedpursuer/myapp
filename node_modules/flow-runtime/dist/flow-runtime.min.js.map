{"version":3,"file":"flow-runtime.min.js","sources":["../src/primitiveTypes.js","../src/errorReporting/makeJSONError.js","../src/Validation.js","../src/errorReporting/RuntimeTypeError.js","../src/errorReporting/makeTypeError.js","../src/makeError.js","../src/compareTypes.js","../src/types/Type.js","../src/types/AnyType.js","../src/errorMessages.js","../src/getErrorMessage.js","../src/types/TupleType.js","../src/cyclic.js","../src/types/ArrayType.js","../src/types/BooleanLiteralType.js","../src/types/BooleanType.js","../src/types/EmptyType.js","../src/types/ExistentialType.js","../src/types/TypeParameter.js","../src/types/FlowIntoType.js","../src/types/FunctionTypeParam.js","../src/types/FunctionTypeRestParam.js","../src/types/FunctionTypeReturn.js","../src/symbols.js","../src/types/FunctionType.js","../src/types/GeneratorType.js","../src/types/TypeParameterApplication.js","../src/types/TypeConstructor.js","../src/types/GenericType.js","../src/invariant.js","../src/typeConstraints.js","../src/types/ObjectTypeProperty.js","../src/types/ObjectTypeIndexer.js","../src/types/ObjectTypeCallProperty.js","../src/types/ObjectType.js","../src/types/IntersectionType.js","../src/types/MixedType.js","../src/types/TypeAlias.js","../src/types/NullLiteralType.js","../src/types/VoidType.js","../src/types/NullableType.js","../src/types/NumericLiteralType.js","../src/types/NumberType.js","../src/types/PartialType.js","../src/types/ParameterizedTypeAlias.js","../src/types/ParameterizedFunctionType.js","../src/types/RefinementType.js","../src/types/StringLiteralType.js","../src/types/StringType.js","../src/types/SymbolLiteralType.js","../src/types/SymbolType.js","../src/types/ThisType.js","../src/types/TypeBox.js","../src/types/TypeReference.js","../src/types/TypeTDZ.js","../src/types/UnionType.js","../src/registerPrimitiveTypes.js","../src/registerBuiltins.js","../src/registerTypePredicates.js","../src/TypeInferrer.js","../src/makeReactPropTypes.js","../src/errorReporting/makeWarningMessage.js","../src/makeUnion.js","../src/classDecorators.js","../src/annotateValue.js","../src/declarations/Declaration.js","../src/declarations/VarDeclaration.js","../src/declarations/TypeDeclaration.js","../src/declarations/ModuleDeclaration.js","../src/declarations/ModuleExportsDeclaration.js","../src/declarations/ClassDeclaration.js","../src/declarations/ParameterizedClassDeclaration.js","../src/declarations/ExtendsDeclaration.js","../src/flowTypes/$DiffType.js","../src/flowTypes/$FlowFixMeType.js","../src/flowTypes/$KeysType.js","../src/flowTypes/$ObjMapiType.js","../src/flowTypes/$ObjMapType.js","../src/flowTypes/$PropertyType.js","../src/flowTypes/$ShapeType.js","../src/flowTypes/$SubType.js","../src/flowTypes/$SuperType.js","../src/flowTypes/$TupleMapType.js","../src/flowTypes/ClassType.js","../src/TypeContext.js","../src/globalContext.js","../src/index.cjs.js"],"sourcesContent":["/* @flow */\n\n/**\n * This file exports a dictionary of global primitive types that are shared by all contexts.\n * It is populated in [registerPrimitiveTypes()](./registerPrimitiveTypes.js).\n */\n\nimport type {\n  Type,\n  NullLiteralType,\n  NumberType,\n  BooleanType,\n  SymbolType,\n  StringType,\n  ExistentialType,\n  AnyType,\n  MixedType,\n  EmptyType,\n  VoidType\n} from './types';\n\n\n/**\n * Covers our builtin types and makes room for future ones.\n */\ntype PrimitiveTypes = {\n  null: NullLiteralType;\n  empty: EmptyType;\n  number: NumberType;\n  boolean: BooleanType;\n  string: StringType;\n  symbol: SymbolType;\n  any: AnyType;\n  mixed: MixedType;\n  void: VoidType;\n  existential: ExistentialType;\n\n  [name: string]: Type<any>;\n};\n\nconst primitiveTypes: any = {};\n\n(primitiveTypes: PrimitiveTypes);\n\nexport default primitiveTypes;","/* @flow */\n\nimport {stringifyPath, resolvePath} from '../Validation';\nimport type Validation from '../Validation';\n\nexport default function makeJSONError <T> (validation: Validation<T>) {\n  if (!validation.hasErrors()) {\n    return;\n  }\n  const {input, context} = validation;\n  const errors = [];\n  for (const [path, message, expectedType] of validation.errors) {\n    const expected = expectedType ? expectedType.toString() : null;\n    const actual = context.typeOf(resolvePath(input, path)).toString();\n    const field = stringifyPath(validation.path.concat(path));\n\n    const pointer = `/${path.join('/')}`;\n\n    errors.push({\n      pointer,\n      field,\n      message,\n      expected,\n      actual\n    });\n  }\n  return errors;\n}\n","/* @flow */\nimport makeJSONError from './errorReporting/makeJSONError';\n\nimport type TypeContext from './TypeContext';\nimport type Type from './types/Type';\n\nexport type IdentifierPath = Array<string | number>;\nexport type ErrorTuple = [IdentifierPath, string, Type<any>];\n\nexport type ValidationJSON<T> = {\n  input: T;\n  errors: Array<{\n    pointer: string;\n    message: string;\n    expected: Type<any>;\n    actual: Type<any>;\n  }>\n};\n\nconst validIdentifierOrAccessor = /^[$A-Z_][0-9A-Z_$[\\].]*$/i;\n\nexport default class Validation<T> {\n\n  context: TypeContext;\n\n  input: T;\n\n  path: string[] = [];\n\n  prefix: string = '';\n\n  errors: ErrorTuple[] = [];\n\n  constructor (context: TypeContext, input: T) {\n    this.context = context;\n    this.input = input;\n  }\n\n  hasErrors (path: ? IdentifierPath): boolean {\n    if (path) {\n      for (const [candidate] of this.errors) {\n        if (matchPath(path, candidate)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    else {\n      return this.errors.length > 0;\n    }\n  }\n\n  addError (path: IdentifierPath, expectedType: Type<any>, message: string): this {\n    this.errors.push([path, message, expectedType]);\n    return this;\n  }\n\n  clearError (path: ? IdentifierPath): boolean {\n    let didClear = false;\n    if (path) {\n      const errors = [];\n      for (const error of this.errors) {\n        if (matchPath(path, error[0])) {\n          didClear = true;\n        }\n        else {\n          errors.push(error);\n        }\n      }\n      this.errors = errors;\n    }\n    else {\n      didClear = this.errors.length > 0;\n      this.errors = [];\n    }\n    return didClear;\n  }\n\n  resolvePath (path: IdentifierPath): any {\n    return resolvePath(this.input, path);\n  }\n\n  toJSON (): * {\n    return makeJSONError(this);\n  }\n\n}\n\nexport function stringifyPath (path: IdentifierPath): string {\n  if (!path.length) {\n    return 'Value';\n  }\n  const {length} = path;\n  const parts = new Array(length);\n  for (let i = 0; i < length; i++) {\n    const part = path[i];\n    if (part === '[[Return Type]]') {\n      parts[i] = 'Return Type';\n    }\n    else if (typeof part !== 'string' || !validIdentifierOrAccessor.test(part)) {\n      parts[i] = `[${String(part)}]`;\n    }\n    else if (i > 0) {\n      parts[i] = `.${part}`;\n    }\n    else {\n      parts[i] = part;\n    }\n  }\n  return parts.join('');\n}\n\nexport function resolvePath (input: any, path: IdentifierPath): any {\n  let subject = input;\n  const {length} = path;\n  for (let i = 0; i < length; i++) {\n    if (subject == null) {\n      return undefined;\n    }\n    const part = path[i];\n    if (part === '[[Return Type]]') {\n      continue;\n    }\n    if (subject instanceof Map) {\n      subject = subject.get(part);\n    }\n    else {\n      subject = subject[part];\n    }\n  }\n  return subject;\n}\n\nexport function matchPath (path: IdentifierPath, candidate: IdentifierPath): boolean {\n  const {length} = path;\n  if (length > candidate.length) {\n    return false;\n  }\n  for (let i = 0; i < length; i++) {\n    if (candidate[i] !== path[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n","/* @flow */\n\nexport default class RuntimeTypeError extends TypeError {\n  name: string = \"RuntimeTypeError\";\n}","/* @flow */\nimport {stringifyPath, resolvePath} from '../Validation';\n\nimport type Validation from '../Validation';\n\nimport RuntimeTypeError from './RuntimeTypeError';\n\nconst delimiter = '\\n-------------------------------------------------\\n\\n';\n\nexport default function makeTypeError <T> (validation: Validation<T>) {\n  if (!validation.hasErrors()) {\n    return;\n  }\n  const {prefix, input, context} = validation;\n  const collected = [];\n  for (const [path, message, expectedType] of validation.errors) {\n    const expected = expectedType ? expectedType.toString() : \"*\";\n    const actual = context.typeOf(resolvePath(input, path)).toString();\n\n    const field = stringifyPath(validation.path.concat(path));\n\n\n    collected.push(\n      `${field} ${message}\\n\\nExpected: ${expected}\\n\\nActual: ${actual}\\n`\n    );\n  }\n  if (prefix) {\n    return new RuntimeTypeError(`${prefix.trim()} ${collected.join(delimiter)}`);\n  }\n  else {\n    return new RuntimeTypeError(collected.join(delimiter));\n  }\n}\n","/* @flow */\n\nimport type {Type} from './types';\nimport makeTypeError from './errorReporting/makeTypeError';\n\nexport default function makeError (expected: Type<any>, input: any): ? TypeError {\n  const {context} = expected;\n  const validation = context.validate(expected, input);\n  return makeTypeError(validation);\n}\n","/* @flow */\n\nimport type Type from './types/Type';\n\nimport {\n  AnyType,\n  ExistentialType,\n  TypeParameter,\n  FlowIntoType,\n  MixedType,\n  TypeAlias\n} from './types';\n\n/**\n * Given two types, A and B, compare them and return either -1, 0, or 1:\n *\n *   -1 if A cannot accept type B.\n *\n *    0 if the types are effectively identical.\n *\n *    1 if A accepts every possible B.\n */\nexport default function compareTypes (a: Type<any>, b: Type<any>): -1 | 0 | 1 {\n\n  if (a === b) {\n    return 0;\n  }\n\n  if (b instanceof TypeAlias || b instanceof TypeParameter) {\n    b = b.unwrap();\n  }\n\n  if (a instanceof TypeAlias) {\n    return a.compareWith(b);\n  }\n\n  if (a instanceof FlowIntoType || a instanceof TypeParameter || b instanceof FlowIntoType) {\n    return a.compareWith(b);\n  }\n  else if (a instanceof AnyType || a instanceof ExistentialType || a instanceof MixedType) {\n    return 1;\n  }\n  else {\n    return a.compareWith(b);\n  }\n}\n","/* @flow */\n\nimport makeError from '../makeError';\nimport compareTypes from '../compareTypes';\n\nimport type TypeContext from '../TypeContext';\n\nimport type Validation, {IdentifierPath} from '../Validation';\n\n\n/**\n * # Type\n *\n * This is the base class for all types.\n */\nexport default class Type <T> {\n  typeName: string = 'Type';\n  context: TypeContext;\n\n  constructor (context: TypeContext) {\n    this.context = context;\n  }\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    return false;\n  }\n\n  accepts (input: any): boolean {\n    throw new Error('Not implemented.');\n  }\n\n  acceptsType (input: Type<any>): boolean {\n    if (compareTypes(this, input) === -1) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    throw new Error('Not implemented.');\n  }\n\n  assert (input: T): T {\n    const error = makeError(this, input);\n    if (error) {\n      if (typeof Error.captureStackTrace === 'function') {\n        Error.captureStackTrace(error, this.assert);\n      }\n      throw error;\n    }\n    return input;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return this;\n  }\n\n  toString () {\n    throw new Error('Not implemented.');\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\n\nimport type Validation, {IdentifierPath} from '../Validation';\n\nexport default class AnyType extends Type<any> {\n  typeName: string = 'AnyType';\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    return false;\n  }\n\n  accepts (input: any): boolean {\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return 1;\n  }\n\n  toString (): string {\n    return 'any';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}","/* @flow */\n\nconst errorMessages = {\n  ERR_CONSTRAINT_VIOLATION: 'violated a constraint',\n  ERR_EXPECT_ARRAY: 'must be an Array',\n  ERR_EXPECT_TRUE: 'must be true',\n  ERR_EXPECT_FALSE: 'must be false',\n  ERR_EXPECT_BOOLEAN: 'must be true or false',\n  ERR_EXPECT_EMPTY: 'must be empty',\n  ERR_EXPECT_EXACT_VALUE: 'must be exactly $0',\n  ERR_EXPECT_CALLABLE: 'must be callable',\n  ERR_EXPECT_CLASS: 'must be a Class of $0',\n  ERR_EXPECT_FUNCTION: 'must be a function',\n  ERR_EXPECT_GENERATOR: 'must be a generator function',\n  ERR_EXPECT_ITERABLE: 'must be iterable',\n  ERR_EXPECT_ARGUMENT: 'argument \"$0\" must be: $1',\n  ERR_EXPECT_RETURN: 'expected return type of: $0',\n  ERR_EXPECT_N_ARGUMENTS: 'requires $0 argument(s)',\n  ERR_EXPECT_INSTANCEOF: 'must be an instance of $0',\n  ERR_EXPECT_KEY_TYPE: 'keys must be: $0',\n  ERR_EXPECT_NULL: 'must be null',\n  ERR_EXPECT_NUMBER: 'must be a number',\n  ERR_EXPECT_OBJECT: 'must be an object',\n  ERR_EXPECT_PROMISE: 'must be promise of $0',\n  ERR_EXPECT_STRING: 'must be a string',\n  ERR_EXPECT_SYMBOL: 'must be a symbol',\n  ERR_EXPECT_THIS: 'must be exactly this',\n  ERR_EXPECT_VOID: 'must be undefined',\n  ERR_INVALID_DATE: 'must be a valid date',\n  ERR_NO_INDEXER: 'is not one of the permitted indexer types',\n  ERR_NO_UNION: 'must be one of: $0',\n  ERR_UNKNOWN_KEY: 'should not contain the key: \"$0\"'\n};\n\nexport type ErrorKey = $Keys<typeof errorMessages>;\n\nexport default errorMessages;","/* @flow */\n\nimport errorMessages from './errorMessages';\nimport type {ErrorKey} from './errorMessages';\n\n\nexport default function getErrorMessage (key: ErrorKey, ...params: any[]): string {\n  const message = errorMessages[key];\n  if (params.length > 0) {\n    return message.replace(/\\$(\\d+)/g, (m, i) => String(params[i]));\n  }\n  else {\n    return message;\n  }\n}\n\n\n","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {IdentifierPath} from '../Validation';\n\nexport default class TupleType<T> extends Type {\n  typeName: string = 'TupleType';\n  types: Type<T>[] = [];\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    const {types} = this;\n    const {length} = types;\n    const {context} = this;\n    if (!context.checkPredicate('Array', input)) {\n      validation.addError(path, this, getErrorMessage('ERR_EXPECT_ARRAY'));\n      return true;\n    }\n    let hasErrors = false;\n    for (let i = 0; i < length; i++) {\n      const type = types[i];\n      if (type.collectErrors(validation, path.concat(i), input[i])) {\n        hasErrors = true;\n      }\n    }\n    return hasErrors;\n  }\n\n  accepts (input: any): boolean {\n    const {types} = this;\n    const {length} = types;\n    const {context} = this;\n\n    if (!context.checkPredicate('Array', input) || input.length < length) {\n      return false;\n    }\n    for (let i = 0; i < length; i++) {\n      const type = types[i];\n      if (!type.accepts(input[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof TupleType)) {\n      return -1;\n    }\n    const types = this.types;\n    const inputTypes = input.types;\n    if (inputTypes.length < types.length) {\n      return -1;\n    }\n    let isGreater = false;\n    for (let i = 0; i < types.length; i++) {\n      const result = compareTypes(types[i], inputTypes[i]);\n      if (result === 1) {\n        isGreater = true;\n      }\n      else if (result === -1) {\n        return -1;\n      }\n    }\n    if (types.length < inputTypes.length) {\n      return 0;\n    }\n    else if (isGreater) {\n      return 1;\n    }\n    else {\n      return 0;\n    }\n  }\n\n  toString (): string {\n    return `[${this.types.join(', ')}]`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      types: this.types\n    };\n  }\n}","/* @flow */\n\nimport type Type from './types/Type';\n\n// Tracks whether we're in validation of cyclic objects.\nconst cyclicValidation = new WeakMap();\n// Tracks whether we're toString() of cyclic objects.\nconst cyclicToString = new WeakSet();\n\nexport function inValidationCycle (type: Type<any>, input: any): boolean {\n  const tracked = cyclicValidation.get(type);\n  if (!tracked) {\n    return false;\n  }\n  else {\n    return tracked.has(input);\n  }\n}\n\nexport function startValidationCycle (type: Type<any>, input: any) {\n  let tracked = cyclicValidation.get(type);\n  if (!tracked) {\n    tracked = new WeakSet();\n    cyclicValidation.set(type, tracked);\n  }\n  tracked.add(input);\n}\n\nexport function endValidationCycle (type: Type<any>, input: any) {\n  const tracked = cyclicValidation.get(type);\n  if (tracked) {\n    tracked.delete(input);\n  }\n}\n\nexport function inToStringCycle (type: Type<any>): boolean {\n  return cyclicToString.has(type);\n}\n\nexport function startToStringCycle (type: Type<any>) {\n  cyclicToString.add(type);\n}\n\nexport function endToStringCycle (type: Type<any>) {\n  cyclicToString.delete(type);\n}\n","/* @flow */\n\nimport Type from './Type';\nimport TupleType from './TupleType';\nimport compareTypes from '../compareTypes';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {IdentifierPath} from '../Validation';\n\nimport {\n  inValidationCycle,\n  startValidationCycle,\n  endValidationCycle,\n  inToStringCycle,\n  startToStringCycle,\n  endToStringCycle\n} from '../cyclic';\n\nexport default class ArrayType <T> extends Type {\n  typeName: string = 'ArrayType';\n  elementType: Type<T>;\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    const {context} = this;\n    if (!context.checkPredicate('Array', input)) {\n      validation.addError(path, this, getErrorMessage('ERR_EXPECT_ARRAY'));\n      return true;\n    }\n    if (inValidationCycle(this, input)) {\n      return false;\n    }\n    startValidationCycle(this, input);\n    const {elementType} = this;\n    const {length} = input;\n\n    let hasErrors = false;\n    for (let i = 0; i < length; i++) {\n      if (elementType.collectErrors(validation, path.concat(i), input[i])) {\n        hasErrors = true;\n      }\n    }\n    endValidationCycle(this, input);\n    return hasErrors;\n  }\n\n  accepts (input: any): boolean {\n    const {context} = this;\n    if (!context.checkPredicate('Array', input)) {\n      return false;\n    }\n    if (inValidationCycle(this, input)) {\n      return true;\n    }\n    startValidationCycle(this, input);\n    const {elementType} = this;\n    const {length} = input;\n    for (let i = 0; i < length; i++) {\n      if (!elementType.accepts(input[i])) {\n        endValidationCycle(this, input);\n        return false;\n      }\n    }\n    endValidationCycle(this, input);\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const {elementType} = this;\n    if (input instanceof TupleType) {\n      const {types} = input;\n      for (let i = 0; i < types.length; i++) {\n        const result = compareTypes(elementType, types[i]);\n        if (result === -1) {\n          return -1;\n        }\n      }\n      return 1;\n    }\n    else if (input instanceof ArrayType) {\n      return compareTypes(elementType, input.elementType);\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    const {elementType} = this;\n    if (inToStringCycle(this)) {\n      if (typeof elementType.name === 'string') {\n        return `Array<$Cycle<${elementType.name}>>`;\n      }\n      else {\n        return `Array<$Cycle<Object>>`;\n      }\n    }\n    startToStringCycle(this);\n    const output = `Array<${elementType.toString()}>`;\n    endToStringCycle(this);\n    return output;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      elementType: this.elementType\n    };\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {IdentifierPath} from '../Validation';\n\nexport default class BooleanLiteralType <T: boolean> extends Type {\n  typeName: string = 'BooleanLiteralType';\n  value: T;\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    if (input !== this.value) {\n      validation.addError(path, this, getErrorMessage(this.value ? 'ERR_EXPECT_TRUE' : 'ERR_EXPECT_FALSE'));\n      return true;\n    }\n    return false;\n  }\n\n  accepts (input: any): boolean {\n    return input === this.value;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof BooleanLiteralType && input.value === this.value) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return this.value ? 'true' : 'false';\n  }\n\n  toJSON () {\n    return {\n      type: this.typeName,\n      value: this.value\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\nimport BooleanLiteralType from './BooleanLiteralType';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {IdentifierPath} from '../Validation';\n\nexport default class BooleanType extends Type {\n  typeName: string = 'BooleanType';\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    if (typeof input !== 'boolean') {\n      validation.addError(path, this, getErrorMessage('ERR_EXPECT_BOOLEAN'));\n      return true;\n    }\n    return false;\n  }\n\n  accepts (input: any): boolean {\n    return typeof input === 'boolean';\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof BooleanLiteralType) {\n      return 1;\n    }\n    else if (input instanceof BooleanType) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString () {\n    return 'boolean';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {IdentifierPath} from '../Validation';\n\nexport default class EmptyType extends Type {\n  typeName: string = 'EmptyType';\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    validation.addError(path, this, getErrorMessage('ERR_EXPECT_EMPTY'));\n    return true;\n  }\n\n  accepts (input: any): boolean {\n    return false; // empty types accepts nothing.\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof EmptyType) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return 'empty';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\n\nimport type Validation, {IdentifierPath} from '../Validation';\n\n\nexport default class ExistentialType extends Type {\n  typeName: string = 'ExistentialType';\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    return false;\n  }\n\n  accepts (input: any): boolean {\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return 1;\n  }\n\n  toString (): string {\n    return '*';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport FlowIntoType from './FlowIntoType';\n\nimport type Validation, {IdentifierPath} from '../Validation';\n\nconst FlowIntoSymbol = Symbol('FlowInto');\n\n/**\n * # TypeParameter\n *\n * Type parameters allow polymorphic type safety.\n * The first time a type parameter is checked, it records the shape of its input,\n * this recorded shape is used to check all future inputs for this particular instance.\n */\nexport default class TypeParameter<T> extends Type {\n  typeName: string = 'TypeParameter';\n  id: string;\n  bound: ? Type<T>;\n  default: ? Type<T>;\n\n  recorded: ? Type<T>;\n\n  // @flowIssue 252\n  [FlowIntoSymbol]: ? FlowIntoType = null;\n\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    const boundOrDefault = this.bound || this.default;\n    const {recorded, context} = this;\n\n    if (boundOrDefault instanceof FlowIntoType) {\n      // We defer to the other type parameter so that values from this\n      // one can flow \"upwards\".\n      return boundOrDefault.accepts(input);\n    }\n    else if (recorded) {\n      // we've already recorded a value for this type parameter\n      return recorded.collectErrors(validation, path, input);\n    }\n    else if (boundOrDefault) {\n      if (boundOrDefault.typeName === 'AnyType' || boundOrDefault.typeName === 'ExistentialType') {\n        return false;\n      }\n      else if (boundOrDefault.collectErrors(validation, path, input)) {\n        return true;\n      }\n    }\n\n    this.recorded = context.typeOf(input);\n    return false;\n  }\n\n  accepts (input: any): boolean {\n    const boundOrDefault = this.bound || this.default;\n    const {recorded, context} = this;\n    if (boundOrDefault instanceof FlowIntoType) {\n      // We defer to the other type parameter so that values from this\n      // one can flow \"upwards\".\n      return boundOrDefault.accepts(input);\n    }\n    else if (recorded) {\n      return recorded.accepts(input);\n    }\n    else if (boundOrDefault) {\n      if (boundOrDefault.typeName === 'AnyType' || boundOrDefault.typeName === 'ExistentialType') {\n        return true;\n      }\n      else if (!boundOrDefault.accepts(input)) {\n        return false;\n      }\n    }\n\n    this.recorded = context.typeOf(input);\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const boundOrDefault = this.bound || this.default;\n    const {recorded} = this;\n    if (input instanceof TypeParameter) {\n      // We don't need to check for `recorded` or `bound` fields\n      // because the input has already been unwrapped, so\n      // if we got a type parameter it must be totally generic and\n      // we treat it like Any.\n      return 1;\n    }\n    else if (recorded) {\n      return compareTypes(recorded, input);\n    }\n    else if (boundOrDefault) {\n      return compareTypes(boundOrDefault, input);\n    }\n    else {\n      // A generic type parameter accepts any input.\n      return 1;\n    }\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    const boundOrDefault = this.bound || this.default;\n    const {recorded} = this;\n    if (recorded) {\n      return recorded.unwrap();\n    }\n    else if (boundOrDefault) {\n      return boundOrDefault.unwrap();\n    }\n    else {\n      return this;\n    }\n  }\n\n  toString (withBinding?: boolean): string {\n    const {id, bound, default: defaultType} = this;\n    if (withBinding) {\n      if (defaultType) {\n        return `${id} = ${defaultType.toString()}`;\n      }\n      else if (bound) {\n        return `${id}: ${bound.toString()}`;\n      }\n    }\n    return id;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      id: this.id,\n      bound: this.bound,\n      recorded: this.recorded\n    };\n  }\n}\n\nexport function flowIntoTypeParameter <T> (typeParameter: TypeParameter<T>): FlowIntoType<T> {\n  const existing: ? FlowIntoType<T> = (typeParameter: $FlowIssue<252>)[FlowIntoSymbol];\n  if (existing) {\n    return existing;\n  }\n\n  const target = new FlowIntoType(typeParameter.context);\n  target.typeParameter = typeParameter;\n  (typeParameter: $FlowIssue<252>)[FlowIntoSymbol] = target;\n  return target;\n}\n","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport type Validation, {IdentifierPath} from '../Validation';\n\nimport TypeParameter from './TypeParameter';\n\n/**\n * # FlowIntoType\n *\n * A virtual type which allows types it receives to \"flow\" upwards into a type parameter.\n * The type parameter will become of a union of any types seen by this instance.\n */\nexport default class FlowIntoType<T: any> extends Type {\n  typeName: string = 'FlowIntoType';\n\n  typeParameter: TypeParameter<T>;\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    const {typeParameter, context} = this;\n\n    const {recorded, bound} = typeParameter;\n\n    if (bound instanceof FlowIntoType) {\n      // We defer to the other type so that values from this\n      // one can flow \"upwards\".\n      return bound.collectErrors(validation, path, input);\n    }\n    if (recorded) {\n      // we've already recorded a value for this type parameter\n      if (bound && bound.collectErrors(validation, path, input)) {\n        return true;\n      }\n      else if (recorded.accepts(input)) {\n        // our existing type already permits this value, there's nothing to do.\n        return false;\n      }\n      else {\n        // we need to make a union\n        typeParameter.recorded = context.union(recorded, context.typeOf(input));\n        return false;\n      }\n    }\n    else if (bound) {\n      if (bound.typeName === 'AnyType' || bound.typeName === 'ExistentialType') {\n        return false;\n      }\n      else if (bound.collectErrors(validation, path, input)) {\n        return true;\n      }\n    }\n\n    typeParameter.recorded = context.typeOf(input);\n    return false;\n  }\n\n  accepts (input: any): boolean {\n    const {typeParameter, context} = this;\n\n    const {recorded, bound} = typeParameter;\n\n    if (bound instanceof FlowIntoType) {\n      // We defer to the other type so that values from this\n      // one can flow \"upwards\".\n      return bound.accepts(input);\n    }\n    if (recorded) {\n      // we've already recorded a value for this type parameter\n      if (bound && !bound.accepts(input)) {\n        return false;\n      }\n      else if (recorded.accepts(input)) {\n        // our existing type already permits this value, there's nothing to do.\n        return true;\n      }\n      else {\n        // we need to make a union\n        typeParameter.recorded = context.union(recorded, context.typeOf(input));\n        return true;\n      }\n    }\n    else if (bound) {\n      if (bound.typeName === 'AnyType' || bound.typeName === 'ExistentialType') {\n        return true;\n      }\n      else if (!bound.accepts(input)) {\n        return false;\n      }\n    }\n\n    typeParameter.recorded = context.typeOf(input);\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const {typeParameter, context} = this;\n\n    const {recorded, bound} = typeParameter;\n    if (bound instanceof FlowIntoType) {\n      // We defer to the other type so that values from this\n      // one can flow \"upwards\".\n      return bound.compareWith(input);\n    }\n    if (recorded) {\n      if (bound && compareTypes(bound, input) === -1) {\n        return -1;\n      }\n      const result = compareTypes(recorded, input);\n      if (result === 0) {\n        // our existing type already permits this value, there's nothing to do.\n        return 0;\n      }\n      // we need to make a union\n      typeParameter.recorded = context.union(recorded, input);\n      return 1;\n    }\n    else if (bound) {\n      if (bound.typeName === 'AnyType' || bound.typeName === 'ExistentialType') {\n        return 1;\n      }\n      const result = compareTypes(bound, input);\n      if (result === -1) {\n        return -1;\n      }\n    }\n\n    typeParameter.recorded = input;\n    return 0;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return this.typeParameter.unwrap();\n  }\n\n  toString (withBinding?: boolean): string {\n    return this.typeParameter.toString(withBinding);\n  }\n\n  toJSON () {\n    return this.typeParameter.toJSON();\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport type Validation, {IdentifierPath} from '../Validation';\n\nexport default class FunctionTypeParam<T> extends Type {\n  typeName: string = 'FunctionTypeParam';\n  name: string;\n  optional: boolean;\n  type: Type<T>;\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    const {optional, type} = this;\n    if (optional && input === undefined) {\n      return false;\n    }\n    else {\n      return type.collectErrors(validation, path, input);\n    }\n  }\n\n  accepts (input: any): boolean {\n    const {optional, type} = this;\n    if (optional && input === undefined) {\n      return true;\n    }\n    else {\n      return type.accepts(input);\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof FunctionTypeParam) {\n      return compareTypes(this.type, input.type);\n    }\n    else {\n      return compareTypes(this.type, input);\n    }\n  }\n\n  toString (): string {\n    const {optional, type} = this;\n    return `${this.name}${optional ? '?' : ''}: ${type.toString()}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      name: this.name,\n      optional: this.optional,\n      type: this.type\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport FunctionTypeParam from './FunctionTypeParam';\n\nimport type Validation, {IdentifierPath} from '../Validation';\n\nexport default class FunctionTypeRestParam<T> extends Type {\n  typeName: string = 'FunctionTypeRestParam';\n  name: string;\n  type: Type<T>;\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    const {type} = this;\n    return type.collectErrors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    const {type} = this;\n    return type.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof FunctionTypeParam || input instanceof FunctionTypeRestParam) {\n      return compareTypes(this.type, input.type);\n    }\n    else {\n      const result = compareTypes(this.type, input);\n      if (result === -1) {\n        return -1;\n      }\n      else {\n        return 1;\n      }\n    }\n  }\n\n  toString (): string {\n    const {type} = this;\n    return `...${this.name}: ${type.toString()}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      name: this.name,\n      type: this.type\n    };\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport type Validation, {IdentifierPath} from '../Validation';\n\n\nexport default class FunctionTypeReturn<T> extends Type {\n  typeName: string = 'FunctionTypeReturn';\n  type: Type<T>;\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    const {type} = this;\n    return type.collectErrors(validation, path.concat('[[Return Type]]'), input);\n  }\n\n  accepts (input: any): boolean {\n    const {type} = this;\n    return type.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof FunctionTypeReturn) {\n      return compareTypes(this.type, input.type);\n    }\n    else {\n      const result = compareTypes(this.type, input);\n      if (result === -1) {\n        return -1;\n      }\n      else {\n        return 1;\n      }\n    }\n  }\n\n  unwrap (): Type<T> {\n    return this.type;\n  }\n\n  toString (): string {\n    const {type} = this;\n    return type.toString();\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}\n","/* @flow */\n\nexport const ParentSymbol = Symbol('Parent');\nexport const NameRegistrySymbol = Symbol('NameRegistry');\nexport const ModuleRegistrySymbol = Symbol('ModuleRegistry');\nexport const CurrentModuleSymbol = Symbol('CurrentModule');\nexport const TypeConstructorRegistrySymbol = Symbol('TypeConstructorRegistry');\nexport const InferrerSymbol = Symbol('Inferrer');\nexport const TraverseValueSymbol = Symbol('TraverseValue');\nexport const TraverseTypeSymbol = Symbol('TraverseType');\nexport const TypeSymbol = Symbol('Type');\nexport const TypeParametersSymbol = Symbol('TypeParameters');\nexport const TypePredicateRegistrySymbol = Symbol('TypePredicateRegistry');\n","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport FunctionTypeParam from './FunctionTypeParam';\nimport FunctionTypeRestParam from './FunctionTypeRestParam';\nimport FunctionTypeReturn from './FunctionTypeReturn';\nimport EmptyType from './EmptyType';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {IdentifierPath} from '../Validation';\n\nimport {TypeSymbol} from '../symbols';\n\nexport default class FunctionType<P, R> extends Type {\n  typeName: string = 'FunctionType';\n  params: FunctionTypeParam<P>[] = [];\n  rest: ? FunctionTypeRestParam<P>;\n  returnType: FunctionTypeReturn<R>;\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    if (typeof input !== 'function') {\n      validation.addError(path, this, getErrorMessage('ERR_EXPECT_FUNCTION'));\n      return true;\n    }\n    const annotation = input[TypeSymbol];\n    const {returnType, params} = this;\n    if (annotation) {\n      let hasErrors = false;\n      for (let i = 0; i < params.length; i++) {\n        const param = params[i];\n        const annotationParam = annotation.params[i];\n        if (!annotationParam && !param.optional) {\n          validation.addError(path, this, getErrorMessage('ERR_EXPECT_ARGUMENT', param.name, param.type.toString()));\n          hasErrors = true;\n        }\n        else if (!param.acceptsType(annotationParam)) {\n          validation.addError(path, this, getErrorMessage('ERR_EXPECT_ARGUMENT', param.name, param.type.toString()));\n          hasErrors = true;\n        }\n      }\n      if (!returnType.acceptsType(annotation.returnType)) {\n        validation.addError(path, this, getErrorMessage('ERR_EXPECT_RETURN', returnType.toString()));\n        hasErrors = true;\n      }\n      return hasErrors;\n    }\n    else {\n      const {context} = this;\n      // We cannot safely check an unannotated function.\n      // But we need to propagate `any` type feedback upwards.\n      for (let i = 0; i < params.length; i++) {\n        const param = params[i];\n        param.acceptsType(context.any());\n      }\n      returnType.acceptsType(context.any());\n      return false;\n    }\n  }\n\n  accepts (input: any): boolean {\n    if (typeof input !== 'function') {\n      return false;\n    }\n    const {returnType, params} = this;\n    const annotation = input[TypeSymbol];\n    if (annotation) {\n      for (let i = 0; i < params.length; i++) {\n        const param = params[i];\n        const annotationParam = annotation.params[i];\n        if (!annotationParam && !param.optional) {\n          return false;\n        }\n        else if (!param.acceptsType(annotationParam)) {\n          return false;\n        }\n      }\n      if (!returnType.acceptsType(annotation.returnType)) {\n        return false;\n      }\n      return true;\n    }\n    else {\n      const {context} = this;\n      // We cannot safely check an unannotated function.\n      // But we need to propagate `any` type feedback upwards.\n      for (let i = 0; i < params.length; i++) {\n        const param = params[i];\n        param.acceptsType(context.any());\n      }\n      returnType.acceptsType(context.any());\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof FunctionType)) {\n      return -1;\n    }\n    const returnType = this.returnType;\n    const inputReturnType = input.returnType;\n    let isGreater = false;\n    const returnTypeResult = compareTypes(returnType, inputReturnType);\n    if (returnTypeResult === -1) {\n      return -1;\n    }\n    else if (returnTypeResult === 1) {\n      isGreater = true;\n    }\n\n    const params = this.params;\n    const inputParams = input.params;\n    if (inputParams.length < params.length) {\n      return -1;\n    }\n    for (let i = 0; i < params.length; i++) {\n      const param = params[i];\n      const inputParam = inputParams[i];\n      const result = compareTypes(param, inputParam);\n      if (result === -1) {\n        return -1;\n      }\n      else if (result === 1) {\n        isGreater = true;\n      }\n    }\n    return isGreater ? 1 : 0;\n  }\n\n  acceptsParams (...args: any[]): boolean {\n    const {params, rest} = this;\n    const paramsLength = params.length;\n    const argsLength = args.length;\n    for (let i = 0; i < paramsLength; i++) {\n      const param = params[i];\n      if (i < argsLength) {\n        if (!param.accepts(args[i])) {\n          return false;\n        }\n      }\n      else if (!param.accepts(undefined)) {\n        return false;\n      }\n    }\n\n    if (argsLength > paramsLength && rest) {\n      for (let i = paramsLength; i < argsLength; i++) {\n        if (!rest.accepts(args[i])) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  acceptsReturn (input: any): boolean {\n    return this.returnType.accepts(input);\n  }\n\n  assertParams (...args: any[]): P[] {\n    const {params, rest} = this;\n    const paramsLength = params.length;\n    const argsLength = args.length;\n    for (let i = 0; i < paramsLength; i++) {\n      const param = params[i];\n      if (i < argsLength) {\n        param.assert(args[i]);\n      }\n      else {\n        param.assert(undefined);\n      }\n    }\n\n    if (argsLength > paramsLength && rest) {\n      for (let i = paramsLength; i < argsLength; i++) {\n        rest.assert(args[i]);\n      }\n    }\n\n    return args;\n  }\n\n  assertReturn <T> (input: any): T {\n    this.returnType.assert(input);\n    return input;\n  }\n\n  invoke (...args: Type<P>[]): Type<R> | EmptyType {\n    const {params, rest, context} = this;\n    const paramsLength = params.length;\n    const argsLength = args.length;\n    for (let i = 0; i < paramsLength; i++) {\n      const param = params[i];\n      if (i < argsLength) {\n        if (!param.acceptsType(args[i])) {\n          return context.empty();\n        }\n      }\n      else if (!param.accepts(undefined)) {\n        return context.empty();\n      }\n    }\n\n    if (argsLength > paramsLength && rest) {\n      for (let i = paramsLength; i < argsLength; i++) {\n        if (!rest.acceptsType(args[i])) {\n          return context.empty();\n        }\n      }\n    }\n\n    return this.returnType.type;\n  }\n\n  toString (): string {\n    const {params, rest, returnType} = this;\n    const args = [];\n    for (let i = 0; i < params.length; i++) {\n      args.push(params[i].toString());\n    }\n    if (rest) {\n      args.push(rest.toString());\n    }\n    return `(${args.join(', ')}) => ${returnType.toString()}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      params: this.params,\n      rest: this.rest,\n      returnType: this.returnType\n    };\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {IdentifierPath} from '../Validation';\n\nexport default class GeneratorType<Y, R, N> extends Type {\n  typeName: string = 'GeneratorType';\n  yieldType: Type<Y>;\n  returnType: Type<R>;\n  nextType: Type<N>;\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    const isValid = input\n      && typeof input.next === 'function'\n      && typeof input.return === 'function'\n      && typeof input.throw === 'function'\n      ;\n    if (isValid) {\n      return false;\n    }\n    else {\n      validation.addError(path, this, getErrorMessage('ERR_EXPECT_GENERATOR'));\n      return true;\n    }\n  }\n\n  accepts (input: any): boolean {\n    return input\n      && typeof input.next === 'function'\n      && typeof input.return === 'function'\n      && typeof input.throw === 'function'\n      ;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof GeneratorType)) {\n      const result = compareTypes(this.yieldType, input);\n      if (result === -1) {\n        return -1;\n      }\n      else {\n        return 1;\n      }\n    }\n    let isGreater = false;\n    let result = compareTypes(this.yieldType, input.yieldType);\n    if (result === -1) {\n      return -1;\n    }\n    else if (result === 1) {\n      isGreater = true;\n    }\n\n    result = compareTypes(this.returnType, input.returnType);\n    if (result === -1) {\n      return -1;\n    }\n    else if (result === 1) {\n      isGreater = true;\n    }\n\n    result = compareTypes(this.nextType, input.nextType);\n    if (result === -1) {\n      return -1;\n    }\n    else if (result === 1) {\n      isGreater = true;\n    }\n\n    return isGreater ? 1 : 0;\n  }\n\n  acceptsYield (input: any): boolean {\n    return this.yieldType.accepts(input);\n  }\n\n  acceptsReturn (input: any): boolean {\n    return this.returnType.accepts(input);\n  }\n\n  acceptsNext (input: any): boolean {\n    return this.nextType.accepts(input);\n  }\n\n  assertYield (input: Y): Y {\n    return this.yieldType.assert(input);\n  }\n\n  assertReturn (input: R): R {\n    return this.returnType.assert(input);\n  }\n\n  assertNext (input: N): N {\n    return this.nextType.assert(input);\n  }\n\n  toString (): string {\n    const {yieldType, returnType, nextType} = this;\n    return `Generator<${yieldType.toString()}, ${returnType.toString()}, ${nextType.toString()}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      yieldType: this.yieldType,\n      returnType: this.returnType,\n      nextType: this.nextType\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport type Validation, {IdentifierPath} from '../Validation';\n\nimport type {ApplicableType} from './';\n\nimport type ObjectTypeProperty from './ObjectTypeProperty';\n\n/**\n * # TypeParameterApplication\n *\n */\nexport default class TypeParameterApplication<X, T> extends Type {\n  typeName: string = 'TypeParameterApplication';\n  parent: ApplicableType<T>;\n  typeInstances: Type<X>[] = [];\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    const {parent, typeInstances} = this;\n    return parent.collectErrors(validation, path, input, ...typeInstances);\n  }\n\n  accepts (input: any): boolean {\n    const {parent, typeInstances} = this;\n    return parent.accepts(input, ...typeInstances);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.parent, input);\n  }\n\n  hasProperty (name: string): boolean {\n    const inner = this.parent;\n    if (inner && typeof (inner: $FlowIgnore).hasProperty === 'function') {\n      return (inner: $FlowIgnore).hasProperty(name, ...this.typeInstances);\n    }\n    else {\n      return false;\n    }\n  }\n\n  getProperty (name: string): ? ObjectTypeProperty<any> {\n    const inner = this.parent;\n    if (inner && typeof (inner: $FlowIgnore).getProperty === 'function') {\n      return (inner: $FlowIgnore).getProperty(name, ...this.typeInstances);\n    }\n  }\n\n  toString (): string {\n    const {parent, typeInstances} = this;\n    const {name} = parent;\n    if (typeInstances.length) {\n      const items = [];\n      for (let i = 0; i < typeInstances.length; i++) {\n        const typeInstance = typeInstances[i];\n        items.push(typeInstance.toString());\n      }\n      return `${name}<${items.join(', ')}>`;\n    }\n    else {\n      return name;\n    }\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      typeInstances: this.typeInstances\n    };\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\nimport type Validation, {IdentifierPath} from '../Validation';\nimport type {Constructor} from './';\n\nimport TypeParameterApplication from './TypeParameterApplication';\n\nexport default class TypeConstructor<T> extends Type {\n  typeName: string = 'TypeConstructor';\n  name: string;\n  impl: ? Constructor<T>;\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    throw new Error(`Not implemented: collectErrors().`);\n  }\n\n  accepts <P> (input: any, ...typeInstances: Type<P>[]): boolean {\n    throw new Error(`Not implemented: accepts().`);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    throw new Error(`Not implemented: compareWith().`);\n  }\n\n  inferTypeParameters <P> (input: any): Type<P>[] {\n    throw new Error(`No inferrer for ${this.name}.`);\n  }\n\n  apply <P> (...typeInstances: Type<P>[]): TypeParameterApplication<P, T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): TypeConstructor<T> {\n    return this;\n  }\n\n  toString (): string {\n    return this.name;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      name: this.name\n    };\n  }\n\n}\n","/* @flow */\n\nimport TypeConstructor from './TypeConstructor';\n\nimport type Type from './Type';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {IdentifierPath} from '../Validation';\n\nexport default class GenericType extends TypeConstructor {\n\n  typeName: string = 'GenericType';\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    const {name, impl} = this;\n    if (input instanceof impl) {\n      return false;\n    }\n    validation.addError(path, this, getErrorMessage('ERR_EXPECT_INSTANCEOF', name));\n    return true;\n  }\n\n  accepts <P> (input: any, ...typeInstances: Type<P>[]): boolean {\n    return input instanceof this.impl;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof GenericType && input.impl === this.impl) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  inferTypeParameters <P> (input: any): Type<P>[] {\n    return [];\n  }\n}","/* @flow */\n\nexport default function invariant (input: any, message: string): void {\n  if (!input) {\n    const error = new Error(message);\n    error.name = 'InvariantViolation';\n    if (typeof Error.captureStackTrace === 'function') {\n      Error.captureStackTrace(error, invariant);\n    }\n    throw error;\n  }\n}","/* @flow */\n\nimport type {\n  Type,\n  TypeConstraint\n} from './types';\n\nimport type Validation, {IdentifierPath} from './Validation';\n\nexport type ConstrainableType<T> = Type<T> & {constraints: TypeConstraint[]};\n\n/**\n * Add constraints to the given subject type.\n */\nexport function addConstraints (subject: ConstrainableType<any>, ...constraints: TypeConstraint[]) {\n  subject.constraints.push(...constraints);\n}\n\n/**\n * Collect any errors from constraints on the given subject type.\n */\nexport function collectConstraintErrors (subject: ConstrainableType<any>, validation: Validation<any>, path: IdentifierPath, ...input: any[]): boolean {\n  const {constraints} = subject;\n  const {length} = constraints;\n  let hasErrors = false;\n  for (let i = 0; i < length; i++) {\n    const constraint = constraints[i];\n    const violation = constraint(...input);\n    if (typeof violation === 'string') {\n      validation.addError(path, this, violation);\n      hasErrors = true;\n    }\n  }\n  return hasErrors;\n}\n\n/**\n * Determine whether the input passes the constraints on the subject type.\n */\nexport function constraintsAccept (subject: ConstrainableType<any>, ...input: any[]): boolean {\n  const {constraints} = subject;\n  const {length} = constraints;\n  for (let i = 0; i < length; i++) {\n    const constraint = constraints[i];\n    if (typeof constraint(...input) === 'string') {\n      return false;\n    }\n  }\n  return true;\n}","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport type {TypeConstraint} from './';\n\nimport type Validation, {IdentifierPath} from '../Validation';\nimport {addConstraints, collectConstraintErrors, constraintsAccept} from '../typeConstraints';\n\n\nexport default class ObjectTypeProperty<K: string | number, V> extends Type {\n  typeName: string = 'ObjectTypeProperty';\n  key: K;\n  value: Type<V>;\n  optional: boolean;\n  // @flowIgnore\n  'static': boolean;\n  constraints: TypeConstraint[] = [];\n\n  addConstraint (...constraints: TypeConstraint[]): ObjectTypeProperty<K, V> {\n    addConstraints(this, ...constraints);\n    return this;\n  }\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    const {optional, key, value} = this;\n    if (optional && input[key] === undefined) {\n      return false;\n    }\n    let hasErrors = false;\n    if (value.collectErrors(validation, path.concat(key), input[key])) {\n      hasErrors = true;\n    }\n    else if (collectConstraintErrors(this, validation, path.concat(key), input[key])) {\n      hasErrors = true;\n    }\n    return hasErrors;\n  }\n\n  accepts (input: Object): boolean {\n    if (this.optional && input[this.key] === undefined) {\n      return true;\n    }\n    else if (!this.value.accepts(input[this.key])) {\n      return false;\n    }\n    else {\n      return constraintsAccept(this, input[this.key]);\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof ObjectTypeProperty)) {\n      return -1;\n    }\n    else if (input.key !== this.key) {\n      return -1;\n    }\n    else {\n      return compareTypes(this.value, input.value);\n    }\n  }\n\n  unwrap (): Type<V> {\n    return this.value.unwrap();\n  }\n\n  toString (): string {\n    if (this.static) {\n      return `static ${this.key}${this.optional ? '?' : ''}: ${this.value.toString()};`;\n    }\n    else {\n      return `${this.key}${this.optional ? '?' : ''}: ${this.value.toString()};`;\n    }\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      key: this.key,\n      value: this.value,\n      optional: this.optional\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport ObjectTypeProperty from './ObjectTypeProperty';\n\nimport type Validation, {IdentifierPath} from '../Validation';\n\nexport default class ObjectTypeIndexer<K: string | number, V> extends Type {\n  typeName: string = 'ObjectTypeIndexer';\n  id: string;\n  key: Type<K>;\n  value: Type<V>;\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, key: any, value: any): boolean {\n    // special case number types\n    if (this.key.typeName === 'NumberType' || this.key.typeName === 'NumericLiteralType') {\n      key = +key;\n    }\n    let hasErrors = this.key.collectErrors(validation, path.concat('[[Key]]'), key);\n    if (this.value.collectErrors(validation, path.concat(key), value)) {\n      hasErrors = true;\n    }\n    return hasErrors;\n  }\n\n  accepts (value: any): boolean {\n    return this.value.accepts(value);\n  }\n\n  acceptsKey (key: any): boolean {\n    // special case number types\n    if (this.key.typeName === 'NumberType' || this.key.typeName === 'NumericLiteralType') {\n      key = +key;\n    }\n    return this.key.accepts(key);\n  }\n\n  acceptsValue (value: any): boolean {\n    return this.value.accepts(value);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof ObjectTypeProperty) {\n      if (!this.key.accepts(input.key)) {\n        return -1;\n      }\n      else {\n        return compareTypes(this.value, input.value);\n      }\n    }\n    else if (!(input instanceof ObjectTypeIndexer)) {\n      return -1;\n    }\n\n    const keyResult = compareTypes(this.key, input.key);\n    if (keyResult === -1) {\n      return -1;\n    }\n    const valueResult = compareTypes(this.value, input.value);\n    if (valueResult === -1) {\n      return -1;\n    }\n\n    if (keyResult === 0 && valueResult === 0) {\n      return 0;\n    }\n    else {\n      return 1;\n    }\n  }\n\n  unwrap (): Type<V> {\n    return this.value.unwrap();\n  }\n\n  toString (): string {\n    return `[${this.id}: ${this.key.toString()}]: ${this.value.toString()};`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      id: this.id,\n      key: this.key,\n      value: this.value\n    };\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport type Validation, {IdentifierPath} from '../Validation';\n\nexport default class ObjectTypeCallProperty<T: Function> extends Type {\n  typeName: string = 'ObjectTypeCallProperty';\n  value: Type<T>;\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    return this.value.collectErrors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    return this.value.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof ObjectTypeCallProperty)) {\n      return -1;\n    }\n    return compareTypes(this.value, input.value);\n  }\n\n  unwrap (): Type<T> {\n    return this.value.unwrap();\n  }\n\n\n  toString (): string {\n    return `${this.value.toString()};`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      value: this.value\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport ObjectTypeProperty from './ObjectTypeProperty';\nimport ObjectTypeIndexer from './ObjectTypeIndexer';\nimport ObjectTypeCallProperty from './ObjectTypeCallProperty';\n\nexport type Property<K: string | number, V>\n = ObjectTypeProperty<K, V>\n | ObjectTypeIndexer<K, V>\n ;\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {IdentifierPath} from '../Validation';\n\nimport {\n  inValidationCycle,\n  startValidationCycle,\n  endValidationCycle,\n  inToStringCycle,\n  startToStringCycle,\n  endToStringCycle\n} from '../cyclic';\n\n\nexport default class ObjectType<T: {}> extends Type {\n  typeName: string = 'ObjectType';\n  properties: ObjectTypeProperty<$Keys<T>, any>[] = [];\n  indexers: ObjectTypeIndexer<any, any>[] = [];\n  callProperties: ObjectTypeCallProperty<any>[] = [];\n  exact: boolean = false;\n\n  /**\n   * Get a property with the given name, or undefined if it does not exist.\n   */\n  getProperty (key: string | number): ? Property<$Keys<T>, any> {\n    const {properties} = this;\n    const {length} = properties;\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      if (property.key === key) {\n        return property;\n      }\n    }\n    return this.getIndexer(key);\n  }\n\n  /**\n   * Determine whether a property with the given name exists.\n   */\n  hasProperty (key: string): boolean {\n    const {properties} = this;\n    const {length} = properties;\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      if (property.key === key) {\n        return true;\n      }\n    }\n    return this.hasIndexer(key);\n  }\n\n\n  /**\n   * Get an indexer with which matches the given key type.\n   */\n  getIndexer <K: string | number> (key: K): ? ObjectTypeIndexer<K, any> {\n    const {indexers} = this;\n    const {length} = indexers;\n    for (let i = 0; i < length; i++) {\n      const indexer = indexers[i];\n      if (indexer.acceptsKey(key)) {\n        return indexer;\n      }\n    }\n  }\n\n  /**\n   * Determine whether an indexer exists which matches the given key type.\n   */\n  hasIndexer (key: string | number): boolean {\n    const {indexers} = this;\n    const {length} = indexers;\n    for (let i = 0; i < length; i++) {\n      const indexer = indexers[i];\n      if (indexer.acceptsKey(key)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    if (input === null) {\n      validation.addError(path, this, getErrorMessage('ERR_EXPECT_OBJECT'));\n      return true;\n    }\n\n    const hasCallProperties = this.callProperties.length > 0;\n\n    if (hasCallProperties) {\n      if (!acceptsCallProperties(this, input)) {\n        validation.addError(path, this, getErrorMessage('ERR_EXPECT_CALLABLE'));\n      }\n    }\n    else if (typeof input !== 'object') {\n      validation.addError(path, this, getErrorMessage('ERR_EXPECT_OBJECT'));\n      return true;\n    }\n    if (inValidationCycle(this, input)) {\n      return false;\n    }\n    startValidationCycle(this, input);\n\n    let result;\n\n    if (this.indexers.length > 0) {\n      result = collectErrorsWithIndexers(this, validation, path, input);\n    }\n    else if (this.exact) {\n      result = collectErrorsExact(this, validation, path, input);\n    }\n    else {\n      result = collectErrorsWithoutIndexers(this, validation, path, input);\n    }\n    endValidationCycle(this, input);\n    return result;\n  }\n\n  accepts (input: any): boolean {\n    if (input === null) {\n      return false;\n    }\n    const hasCallProperties = this.callProperties.length > 0;\n\n    if (hasCallProperties) {\n      if (!acceptsCallProperties(this, input)) {\n        return false;\n      }\n    }\n    else if (typeof input !== 'object') {\n      return false;\n    }\n    if (inValidationCycle(this, input)) {\n      return true;\n    }\n    startValidationCycle(this, input);\n\n    let result;\n    if (this.indexers.length > 0) {\n      result = acceptsWithIndexers(this, input);\n    }\n    else if (this.exact) {\n      result = acceptsExact(this, input);\n    }\n    else {\n      result = acceptsWithoutIndexers(this, input);\n    }\n    endValidationCycle(this, input);\n    return result;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof ObjectType)) {\n      return -1;\n    }\n    const hasCallProperties = this.callProperties.length > 0;\n\n    let isGreater = false;\n    if (hasCallProperties) {\n      const result = compareTypeCallProperties(this, input);\n      if (result === -1) {\n        return -1;\n      }\n      else if (result === 1) {\n        isGreater = true;\n      }\n    }\n\n    let result;\n    if (this.indexers.length > 0) {\n      result = compareTypeWithIndexers(this, input);\n    }\n    else {\n      result = compareTypeWithoutIndexers(this, input);\n    }\n\n    if (result === -1) {\n      return -1;\n    }\n    else if (isGreater) {\n      return 1;\n    }\n    else {\n      return result;\n    }\n  }\n\n  toString (): string {\n    const {callProperties, properties, indexers} = this;\n    if (inToStringCycle(this)) {\n      return '$Cycle<Object>';\n    }\n    startToStringCycle(this);\n    const body = [];\n    for (let i = 0; i < callProperties.length; i++) {\n      body.push(callProperties[i].toString());\n    }\n    for (let i = 0; i < properties.length; i++) {\n      body.push(properties[i].toString());\n    }\n    for (let i = 0; i < indexers.length; i++) {\n      body.push(indexers[i].toString());\n    }\n    endToStringCycle(this);\n    if (this.exact) {\n      return `{|\\n${indent(body.join('\\n'))}\\n|}`;\n    }\n    else {\n      return `{\\n${indent(body.join('\\n'))}\\n}`;\n    }\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      callProperties: this.callProperties,\n      properties: this.properties,\n      indexers: this.indexers,\n      exact: this.exact\n    };\n  }\n}\n\nfunction acceptsCallProperties (type: ObjectType<any>, input: any): boolean {\n  if (typeof input !== 'function') {\n    return false;\n  }\n  const {callProperties} = type;\n  for (let i = 0; i < callProperties.length; i++) {\n    const callProperty = callProperties[i];\n    if (callProperty.accepts(input)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n\nfunction compareTypeCallProperties (type: ObjectType<any>, input: ObjectType<any>): -1 | 0 | 1 {\n  const {callProperties} = type;\n  const inputCallProperties = input.callProperties;\n  let identicalCount = 0;\n  loop: for (let i = 0; i < callProperties.length; i++) {\n    const callProperty = callProperties[i];\n\n    for (let j = 0; j < inputCallProperties.length; j++) {\n      const inputCallProperty = inputCallProperties[j];\n      const result = compareTypes(callProperty, inputCallProperty);\n      if (result === 0) {\n        identicalCount++;\n        continue loop;\n      }\n      else if (result === 1) {\n        continue loop;\n      }\n    }\n    // If we got this far, nothing accepted.\n    return -1;\n  }\n  if (identicalCount === callProperties.length) {\n    return 0;\n  }\n  else {\n    return 1;\n  }\n}\n\nfunction acceptsWithIndexers (type: ObjectType<any>, input: Object): boolean {\n  const {properties, indexers} = type;\n  const seen = [];\n  for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n    if (!property.accepts(input)) {\n      return false;\n    }\n    seen.push(property.key);\n  }\n  loop: for (const key in input) {\n    if (seen.indexOf(key) !== -1) {\n      continue;\n    }\n    const value = input[key];\n    for (let i = 0; i < indexers.length; i++) {\n      const indexer = indexers[i];\n      if (indexer.acceptsKey(key) && indexer.acceptsValue(value)) {\n        continue loop;\n      }\n    }\n\n    // if we got this far the key / value did not accepts any indexers.\n    return false;\n  }\n  return true;\n}\n\nfunction compareTypeWithIndexers (type: ObjectType<any>, input: ObjectType<any>): -1 | 0 | 1 {\n  const {indexers, properties} = type;\n  const inputIndexers = input.indexers;\n  const inputProperties = input.properties;\n  let isGreater = false;\n  loop: for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n    for (let j = 0; j < inputProperties.length; j++) {\n      const inputProperty = inputProperties[j];\n      if (inputProperty.key === property.key) {\n        const result = compareTypes(property, inputProperty);\n        if (result === -1) {\n          return -1;\n        }\n        else if (result === 1) {\n          isGreater = true;\n        }\n        continue loop;\n      }\n    }\n  }\n  loop: for (let i = 0; i < indexers.length; i++) {\n    const indexer = indexers[i];\n    for (let j = 0; j < inputIndexers.length; j++) {\n      const inputIndexer = inputIndexers[j];\n      const result = compareTypes(indexer, inputIndexer);\n      if (result === 1) {\n        isGreater = true;\n        continue loop;\n      }\n      else if (result === 0) {\n        continue loop;\n      }\n    }\n    // if we got this far, nothing accepted\n    return -1;\n  }\n  return isGreater ? 1 : 0;\n}\n\n\nfunction acceptsWithoutIndexers (type: ObjectType<any>, input: Object): boolean {\n  const {properties} = type;\n  for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n    if (!property.accepts(input)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n\nfunction acceptsExact (type: ObjectType<any>, input: Object): boolean {\n  const {properties} = type;\n  const {length} = properties;\n  loop: for (const key in input) { // eslint-disable-line guard-for-in\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      if (property.key === key) {\n        if (!property.accepts(input)) {\n          return false;\n        }\n        continue loop;\n      }\n    }\n    // if we got this far the property does not exist in the object.\n    return false;\n  }\n  return true;\n}\n\nfunction compareTypeWithoutIndexers (type: ObjectType<any>, input: ObjectType<any>): -1 | 0 | 1 {\n  const {properties} = type;\n  const inputProperties = input.properties;\n  let isGreater = false;\n  loop: for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n    for (let j = 0; j < inputProperties.length; j++) {\n      const inputProperty = inputProperties[j];\n      if (inputProperty.key === property.key) {\n        const result = compareTypes(property, inputProperty);\n        if (result === -1) {\n          return -1;\n        }\n        else if (result === 1) {\n          isGreater = true;\n        }\n        continue loop;\n      }\n    }\n    return -1;\n  }\n  return isGreater ? 1 : 0;\n}\n\n\nfunction collectErrorsWithIndexers (type: ObjectType<any>, validation: Validation<any>, path: IdentifierPath, input: Object): boolean {\n  const {properties, indexers} = type;\n  const seen = [];\n  let hasErrors = false;\n  for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n    if (property.collectErrors(validation, path, input)) {\n      hasErrors = true;\n    }\n    seen.push(property.key);\n  }\n  loop: for (const key in input) {\n    if (seen.indexOf(key) !== -1) {\n      continue;\n    }\n    const value = input[key];\n    for (let i = 0; i < indexers.length; i++) {\n      const indexer = indexers[i];\n      if (indexer.acceptsKey(key) && indexer.acceptsValue(value)) {\n        continue loop;\n      }\n    }\n\n    // if we got this far the key / value was not accepted by any indexers.\n    validation.addError(path.concat(key), type, getErrorMessage('ERR_NO_INDEXER'));\n    hasErrors = true;\n  }\n  return hasErrors;\n}\n\n\nfunction collectErrorsWithoutIndexers (type: ObjectType<any>, validation: Validation<any>, path: IdentifierPath, input: Object): boolean {\n  const {properties} = type;\n  let hasErrors = false;\n  for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n    if (property.collectErrors(validation, path, input)) {\n      hasErrors = true;\n    }\n  }\n  return hasErrors;\n}\n\n\nfunction collectErrorsExact (type: ObjectType<any>, validation: Validation<any>, path: IdentifierPath, input: Object): boolean {\n  const {properties} = type;\n  const {length} = properties;\n  let hasErrors = false;\n  loop: for (const key in input) { // eslint-disable-line guard-for-in\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      if (property.key === key) {\n        if (property.collectErrors(validation, path, input)) {\n          hasErrors = true;\n        }\n        continue loop;\n      }\n    }\n    // if we got this far the property does not exist in the object.\n    validation.addError(path, type, getErrorMessage('ERR_UNKNOWN_KEY', key));\n    hasErrors = true;\n  }\n  return hasErrors;\n}\n\nfunction indent (input: string): string {\n  const lines = input.split('\\n');\n  const {length} = lines;\n  for (let i = 0; i < length; i++) {\n    lines[i] = `  ${lines[i]}`;\n  }\n  return lines.join('\\n');\n}\n","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport invariant from '../invariant';\n\nimport ObjectType from './ObjectType';\nimport type {Property} from './ObjectType';\nimport type ObjectTypeProperty from './ObjectTypeProperty';\nimport type Validation, {IdentifierPath} from '../Validation';\n\nexport default class IntersectionType<T: {}> extends Type {\n  typeName: string = 'IntersectionType';\n  types: Type<T>[] = [];\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    const {types} = this;\n    const {length} = types;\n    let hasErrors = false;\n    for (let i = 0; i < length; i++) {\n      const type = types[i];\n      if (type.collectErrors(validation, path, input)) {\n        hasErrors = true;\n      }\n    }\n    return hasErrors;\n  }\n\n\n  /**\n   * Get a property with the given name, or undefined if it does not exist.\n   */\n  getProperty <K: string | number> (key: K): ? Property<K, any> {\n    const {types} = this;\n    const {length} = types;\n    for (let i = length - 1; i >= 0; i--) {\n      const type = types[i];\n      if (typeof type.getProperty === 'function') {\n        const prop = type.getProperty(key);\n        if (prop) {\n          return prop;\n        }\n      }\n    }\n  }\n\n  /**\n   * Determine whether a property with the given name exists.\n   */\n  hasProperty (key: string): boolean {\n    const {types} = this;\n    const {length} = types;\n    for (let i = 0; i < length; i++) {\n      const type = types[i];\n      if (typeof type.hasProperty === 'function' && type.hasProperty(key)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  accepts (input: any): boolean {\n    const {types} = this;\n    const {length} = types;\n    for (let i = 0; i < length; i++) {\n      const type = types[i];\n      if (!type.accepts(input)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const types = this.types;\n    let identicalCount = 0;\n    if (input instanceof IntersectionType) {\n      const inputTypes = input.types;\n      loop: for (let i = 0; i < types.length; i++) {\n        const type = types[i];\n        for (let j = 0; j < inputTypes.length; j++) {\n          const result = compareTypes(type, inputTypes[i]);\n          if (result === 0) {\n            identicalCount++;\n            continue loop;\n          }\n          else if (result === 1) {\n            continue loop;\n          }\n        }\n        // if we got this far then nothing accepted this type.\n        return -1;\n      }\n      return identicalCount === types.length ? 0 : 1;\n    }\n    else {\n      for (let i = 0; i < types.length; i++) {\n        const type = types[i];\n        const result = compareTypes(type, input);\n        if (result === -1) {\n          return -1;\n        }\n        else if (result === 0) {\n          identicalCount++;\n        }\n      }\n      return identicalCount === types.length ? 0 : 1;\n    }\n  }\n\n  unwrap (): ObjectType<T> {\n    const callProperties = [];\n    const properties = [];\n    const indexers = [];\n    const {types, context} = this;\n    for (let i = 0; i < types.length; i++) {\n      const type = types[i].unwrap();\n      invariant(type instanceof ObjectType, 'Can only intersect object types');\n      callProperties.push(...type.callProperties);\n      indexers.push(...type.indexers);\n      mergeProperties(properties, type.properties);\n    }\n    return (context: any).object(\n      ...callProperties,\n      ...properties,\n      ...indexers\n    );\n  }\n\n  toString (): string {\n    return this.types.join(' & ');\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      types: this.types\n    };\n  }\n}\n\nfunction getPropertyIndex <K: string | number, V> (name: K, properties: ObjectTypeProperty<*, V>[]): number {\n  for (let i = 0; i < properties.length; i++) {\n    if (properties[i].name === name) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nfunction mergeProperties <K: string | number, V> (target: ObjectTypeProperty<K, V>[], source: ObjectTypeProperty<K, V>[]): ObjectTypeProperty<K, V>[] {\n  for (let i = 0; i < source.length; i++) {\n    const typeProp = source[i];\n    const index = getPropertyIndex(typeProp.key, target);\n    if (index === -1) {\n      target.push(typeProp);\n    }\n    else {\n      target[index] = typeProp;\n    }\n  }\n  return target;\n}\n","/* @flow */\n\nimport Type from './Type';\n\nimport type Validation, {IdentifierPath} from '../Validation';\n\nexport default class MixedType extends Type {\n  typeName: string = 'MixedType';\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    return false;\n  }\n\n  accepts (input: any): boolean {\n    return true;\n  }\n\n  toString (): string {\n    return 'mixed';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}","\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport type {TypeConstraint} from './';\nimport type Validation, {IdentifierPath} from '../Validation';\n\nimport type ObjectTypeProperty from './ObjectTypeProperty';\n\nimport TypeParameterApplication from './TypeParameterApplication';\nimport {addConstraints, collectConstraintErrors, constraintsAccept} from '../typeConstraints';\n\nexport default class TypeAlias<T> extends Type {\n  typeName: string = 'TypeAlias';\n  name: string;\n  type: Type<T>;\n  constraints: TypeConstraint[] = [];\n\n  addConstraint (...constraints: TypeConstraint[]): TypeAlias<T> {\n    addConstraints(this, ...constraints);\n    return this;\n  }\n\n  get hasConstraints (): boolean {\n    return this.constraints.length > 0;\n  }\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    const {type} = this;\n    let hasErrors = false;\n    if (type.collectErrors(validation, path, input)) {\n      hasErrors = true;\n    }\n    else if (collectConstraintErrors(this, validation, path, input)) {\n      hasErrors = true;\n    }\n    return hasErrors;\n  }\n\n  accepts (input: any): boolean {\n    const {type} = this;\n    if (!type.accepts(input)) {\n      return false;\n    }\n    else if (!constraintsAccept(this, input)) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input === this) {\n      return 0; // should never need this because it's taken care of by compareTypes.\n    }\n    else if (this.hasConstraints) {\n      // if we have constraints the types cannot be the same\n      return -1;\n    }\n    else {\n      return compareTypes(this.type, input);\n    }\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<X, T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return this.type.unwrap();\n  }\n\n  hasProperty (name: string): boolean {\n    const inner = this.unwrap();\n    if (inner && typeof inner.hasProperty === 'function') {\n      return inner.hasProperty(name);\n    }\n    else {\n      return false;\n    }\n  }\n\n  getProperty (name: string): ? ObjectTypeProperty<any> {\n    const inner = this.unwrap();\n    if (inner && typeof inner.getProperty === 'function') {\n      return inner.getProperty(name);\n    }\n  }\n\n  toString (withDeclaration?: boolean): string {\n    const {name, type} = this;\n    if (withDeclaration) {\n      return `type ${name} = ${type.toString()};`;\n    }\n    else {\n      return name;\n    }\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      name: this.name,\n      type: this.type\n    };\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {IdentifierPath} from '../Validation';\n\nexport default class NullLiteralType extends Type {\n  typeName: string = 'NullLiteralType';\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    if (input === null) {\n      return false;\n    }\n    validation.addError(path, this, getErrorMessage('ERR_EXPECT_NULL'));\n    return true;\n  }\n\n  accepts (input: any): boolean {\n    return input === null;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof NullLiteralType) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return 'null';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {IdentifierPath} from '../Validation';\n\nexport default class VoidType extends Type {\n  typeName: string = 'VoidType';\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    if (input === undefined) {\n      return false;\n    }\n    else {\n      validation.addError(path, this, getErrorMessage('ERR_EXPECT_VOID'));\n      return true;\n    }\n  }\n\n  accepts (input: any): boolean {\n    return input === undefined;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof VoidType) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return 'void';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport NullLiteralType from './NullLiteralType';\nimport VoidType from './VoidType';\nimport type Validation, {IdentifierPath} from '../Validation';\n\nexport default class NullableType<T> extends Type<T> {\n  typeName: string = 'NullableType';\n  type: Type<T>;\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    if (input == null) {\n      return false;\n    }\n    else {\n      return this.type.collectErrors(validation, path, input);\n    }\n  }\n\n  accepts (input: any): boolean {\n    if (input == null) {\n      return true;\n    }\n    else {\n      return this.type.accepts(input);\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof NullLiteralType || input instanceof VoidType) {\n      return 1;\n    }\n    else if (input instanceof NullableType) {\n      return compareTypes(this.type, input.type);\n    }\n    else {\n      const result = compareTypes(this.type, input);\n      if (result === -1) {\n        return -1;\n      }\n      else {\n        return 1;\n      }\n    }\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return this.type.unwrap();\n  }\n\n  toString (): string {\n    return `? ${this.type.toString()}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {IdentifierPath} from '../Validation';\n\nexport default class NumericLiteralType<T: number> extends Type {\n  typeName: string = 'NumericLiteralType';\n  value: T;\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    const {value} = this;\n    if (input === value) {\n      return false;\n    }\n    else {\n      validation.addError(path, this, getErrorMessage('ERR_EXPECT_EXACT_VALUE', value));\n      return false;\n    }\n  }\n\n  accepts (input: any): boolean {\n    return input === this.value;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof NumericLiteralType && input.value === this.value) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return `${this.value}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      value: this.value\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\nimport NumericLiteralType from './NumericLiteralType';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {IdentifierPath} from '../Validation';\n\nexport default class NumberType extends Type {\n  typeName: string = 'NumberType';\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    if (typeof input === 'number') {\n      return false;\n    }\n    else {\n      validation.addError(path, this, getErrorMessage('ERR_EXPECT_NUMBER'));\n      return false;\n    }\n  }\n\n  accepts (input: any): boolean {\n    return typeof input === 'number';\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof NumberType) {\n      return 0;\n    }\n    else if (input instanceof NumericLiteralType) {\n      return 1;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return 'number';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n","\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport type {TypeConstraint} from './';\nimport type Validation, {IdentifierPath} from '../Validation';\n\nimport TypeParameter from './TypeParameter';\nimport TypeParameterApplication from './TypeParameterApplication';\n\nimport {collectConstraintErrors, constraintsAccept} from '../typeConstraints';\n\nexport default class PartialType<X, T> extends Type {\n  typeName: string = 'PartialType';\n  name: string;\n  type: Type<T>;\n  typeParameters: TypeParameter<X>[] = [];\n  constraints: ? TypeConstraint[];\n\n  typeParameter (id: string, bound?: Type<X>, defaultType?: Type<X>): TypeParameter<X> {\n    const target = new TypeParameter(this.context);\n    target.id = id;\n    target.bound = bound;\n    target.default = defaultType;\n    this.typeParameters.push(target);\n    return target;\n  }\n\n  apply (...typeInstances: Type<X>[]): TypeParameterApplication<X, T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    const {constraints, type} = this;\n    let hasErrors = false;\n    if (type.collectErrors(validation, path, input)) {\n      hasErrors = true;\n    }\n    else if (constraints && collectConstraintErrors(this, validation, path, input)) {\n      hasErrors = true;\n    }\n    return hasErrors;\n  }\n\n  accepts (input: any): boolean {\n    const {constraints, type} = this;\n    if (!type.accepts(input)) {\n      return false;\n    }\n    else if (constraints && !constraintsAccept(this, input)) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input === this) {\n      return 0;\n    }\n    else {\n      return compareTypes(this.type, input);\n    }\n  }\n\n  toString (expand?: boolean): string {\n    const {type} = this;\n    return type.toString(expand);\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return this.type.unwrap();\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      typeParameters: this.typeParameters,\n      type: this.type\n    };\n  }\n}","\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport type {TypeCreator} from './';\nimport type Validation, {IdentifierPath} from '../Validation';\nimport TypeAlias from './TypeAlias';\nimport PartialType from './PartialType';\nimport type ObjectTypeProperty from './ObjectTypeProperty';\n\nimport {constraintsAccept} from '../typeConstraints';\n\n\nexport default class ParameterizedTypeAlias <T: Type> extends TypeAlias {\n  typeName: string = 'ParameterizedTypeAlias';\n\n  typeCreator: TypeCreator<T>;\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any, ...typeInstances: Type<any>[]): boolean {\n    const partial = getPartial(this, ...typeInstances);\n\n    return partial.collectErrors(validation, path, input);\n  }\n\n  accepts (input: any, ...typeInstances: Type<any>[]): boolean {\n    const partial = getPartial(this, ...typeInstances);\n    if (!partial.accepts(input)) {\n      return false;\n    }\n    else if (!constraintsAccept(this, input)) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input === this) {\n      return 0; // should never need this because it's taken care of by compareTypes.\n    }\n    else if (this.hasConstraints) {\n      // if we have constraints the types cannot be the same\n      return -1;\n    }\n    else {\n      return compareTypes(getPartial(this), input);\n    }\n  }\n\n  hasProperty (name: string, ...typeInstances: Type<any>[]): boolean {\n    const inner = this.unwrap(...typeInstances);\n    if (inner && typeof inner.hasProperty === 'function') {\n      return inner.hasProperty(name, ...typeInstances);\n    }\n    else {\n      return false;\n    }\n  }\n\n  getProperty (name: string, ...typeInstances: Type<any>[]): ? ObjectTypeProperty<any> {\n    const inner = this.unwrap(...typeInstances);\n    if (inner && typeof inner.getProperty === 'function') {\n      return inner.getProperty(name, ...typeInstances);\n    }\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (...typeInstances: Type<any>[]): Type<any> {\n    return getPartial(this, ...typeInstances).unwrap();\n  }\n\n  toString (withDeclaration?: boolean): string {\n    const partial = getPartial(this);\n    const {typeParameters} = partial;\n    const items = [];\n    for (let i = 0; i < typeParameters.length; i++) {\n      const typeParameter = typeParameters[i];\n      items.push(typeParameter.toString(true));\n    }\n\n    const {name} = this;\n    const identifier = typeParameters.length > 0\n                     ? `${name}<${items.join(', ')}>`\n                     : name\n                     ;\n\n    if (withDeclaration) {\n      return `type ${identifier} = ${partial.toString()};`;\n    }\n    else {\n      return identifier;\n    }\n  }\n\n  toJSON () {\n    const partial = getPartial(this);\n    return partial.toJSON();\n  }\n}\n\nfunction getPartial <T> (parent: ParameterizedTypeAlias<T>, ...typeInstances: Type<any>[]): PartialType<T> {\n\n  const {typeCreator, context, name} = parent;\n  const partial = new PartialType(context);\n  partial.name = name;\n  partial.type = typeCreator(partial);\n  partial.constraints = parent.constraints;\n\n  const {typeParameters} = partial;\n  const limit = Math.min(typeInstances.length, typeParameters.length);\n  for (let i = 0; i < limit; i++) {\n    const typeParameter = typeParameters[i];\n    const typeInstance = typeInstances[i];\n    if (typeParameter.bound && typeParameter.bound !== typeInstance) {\n      // if the type parameter is already bound we need to\n      // create an intersection type with this one.\n      typeParameter.bound = context.intersect(typeParameter.bound, typeInstance);\n    }\n    else {\n      typeParameter.bound = typeInstance;\n    }\n  }\n\n  return partial;\n}\n","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport PartialType from './PartialType';\nimport type FunctionTypeParam from './FunctionTypeParam';\nimport type FunctionTypeRestParam from './FunctionTypeRestParam';\nimport type FunctionTypeReturn from './FunctionTypeReturn';\nimport type TypeParameter from './TypeParameter';\n\nimport type Validation, {IdentifierPath} from '../Validation';\n\nexport type FunctionBodyCreator <P, R> = (partial: PartialType<(...params: P[]) => R>) => Array<FunctionTypeParam<P> | FunctionTypeRestParam<P> | FunctionTypeReturn<R>>;\n\n\nexport default class ParameterizedFunctionType <X, P: any, R: any> extends Type {\n  typeName: string = 'ParameterizedFunctionType';\n  bodyCreator: FunctionBodyCreator<P, R>;\n\n  get typeParameters (): TypeParameter<X>[] {\n    return getPartial(this).typeParameters;\n  }\n\n  get params (): FunctionTypeParam<P>[] {\n    return getPartial(this).type.params;\n  }\n\n  get rest (): ? FunctionTypeRestParam<P> {\n    return getPartial(this).type.rest;\n  }\n\n  get returnType (): Type<R> {\n    return getPartial(this).type.returnType;\n  }\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any, ...typeInstances: Type<any>[]): boolean {\n    return getPartial(this, ...typeInstances).collectErrors(validation, path, input);\n  }\n\n  accepts (input: any, ...typeInstances: Type<any>[]): boolean {\n    return getPartial(this, ...typeInstances).accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(getPartial(this), input);\n  }\n\n  acceptsParams (...args: any[]): boolean {\n    return getPartial(this).type.acceptsParams(...args);\n  }\n\n  acceptsReturn (input: any): boolean {\n    return getPartial(this).type.acceptsReturn(input);\n  }\n\n  assertParams <T> (...args: T[]): T[] {\n    return getPartial(this).type.assertParams(...args);\n  }\n\n  assertReturn <T> (input: T): T {\n    return getPartial(this).type.assertReturn(input);\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (...typeInstances: Type<any>[]): Type<(...params: P[]) => R | any> {\n    return getPartial(this, ...typeInstances).unwrap();\n  }\n\n  toString (): string {\n    const partial = getPartial(this);\n    const {type, typeParameters} = partial;\n    if (typeParameters.length === 0) {\n      return type.toString();\n    }\n    const items = [];\n    for (let i = 0; i < typeParameters.length; i++) {\n      const typeParameter = typeParameters[i];\n      items.push(typeParameter.toString(true));\n    }\n    return `<${items.join(', ')}> ${type.toString()}`;\n  }\n\n  toJSON () {\n    const partial = getPartial(this);\n    return partial.toJSON();\n  }\n}\n\nfunction getPartial <X, P, R> (parent: ParameterizedFunctionType<X, P, R>, ...typeInstances: Type<any>[]): PartialType<(...params: P[]) => R> {\n\n  const {context, bodyCreator} = parent;\n  const partial = new PartialType(context);\n  const body = bodyCreator(partial);\n  partial.type = context.function(...body);\n\n  const {typeParameters} = partial;\n  const limit = Math.min(typeInstances.length, typeParameters.length);\n  for (let i = 0; i < limit; i++) {\n    const typeParameter = typeParameters[i];\n    const typeInstance = typeInstances[i];\n    if (typeParameter.bound && typeParameter.bound !== typeInstance) {\n      // if the type parameter is already bound we need to\n      // create an intersection type with this one.\n      typeParameter.bound = context.intersect(typeParameter.bound, typeInstance);\n    }\n    else {\n      typeParameter.bound = typeInstance;\n    }\n  }\n\n  return partial;\n}\n","\nimport Type from './Type';\nimport type {TypeConstraint} from './';\nimport type Validation, {IdentifierPath} from '../Validation';\n\nimport type ObjectTypeProperty from './ObjectTypeProperty';\n\nimport TypeParameterApplication from './TypeParameterApplication';\nimport {addConstraints, collectConstraintErrors, constraintsAccept} from '../typeConstraints';\n\nexport default class RefinementType<T> extends Type {\n  typeName: string = 'RefinementType';\n  type: Type<T>;\n  constraints: TypeConstraint[] = [];\n\n  addConstraint (...constraints: TypeConstraint[]): RefinementType<T> {\n    addConstraints(this, ...constraints);\n    return this;\n  }\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    const {type} = this;\n    if (type.collectErrors(validation, path, input)) {\n      return true;\n    }\n    else if (collectConstraintErrors(this, validation, path, input)) {\n      return true;\n    }\n    return false;\n  }\n\n  accepts (input: any): boolean {\n    const {type} = this;\n    if (!type.accepts(input)) {\n      return false;\n    }\n    else if (!constraintsAccept(this, input)) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input === this) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<X, T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return this.type.unwrap();\n  }\n\n  hasProperty (name: string): boolean {\n    const inner = this.unwrap();\n    if (inner && typeof inner.hasProperty === 'function') {\n      return inner.hasProperty(name);\n    }\n    else {\n      return false;\n    }\n  }\n\n  getProperty (name: string): ? ObjectTypeProperty<any> {\n    const inner = this.unwrap();\n    if (inner && typeof inner.getProperty === 'function') {\n      return inner.getProperty(name);\n    }\n  }\n\n  toString (): string {\n    const {type} = this;\n    return `$Refinment<${type.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {IdentifierPath} from '../Validation';\n\nexport default class StringLiteralType<T: string> extends Type {\n  typeName: string = 'StringLiteralType';\n  value: T;\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    const {value} = this;\n    if (input === value) {\n      return false;\n    }\n    else {\n      validation.addError(path, this, getErrorMessage('ERR_EXPECT_EXACT_VALUE', this.toString()));\n      return true;\n    }\n  }\n\n  accepts (input: any): boolean {\n    return input === this.value;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof StringLiteralType && input.value === this.value) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return JSON.stringify(this.value);\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      value: this.value\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\nimport StringLiteralType from './StringLiteralType';\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {IdentifierPath} from '../Validation';\n\nexport default class StringType extends Type {\n  typeName: string = 'StringType';\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    if (typeof input === 'string') {\n      return false;\n    }\n    else {\n      validation.addError(path, this, getErrorMessage('ERR_EXPECT_STRING'));\n      return true;\n    }\n  }\n\n  accepts (input: any): boolean {\n    return typeof input === 'string';\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof StringLiteralType) {\n      return 1;\n    }\n    else if (input instanceof StringType) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString () {\n    return 'string';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n\n","/* @flow */\n\nimport Type from './Type';\nimport getErrorMessage from '../getErrorMessage';\nimport type Validation, {IdentifierPath} from '../Validation';\n\nexport default class SymbolLiteralType<T: Symbol> extends Type {\n  typeName: string = 'SymbolLiteralType';\n  value: T;\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    const {value} = this;\n    if (input === value) {\n      return false;\n    }\n    else {\n      validation.addError(path, this, getErrorMessage('ERR_EXPECT_EXACT_VALUE', this.toString()));\n      return true;\n    }\n  }\n\n  accepts (input: any): boolean {\n    return input === this.value;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof SymbolLiteralType && input.value === this.value) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString () {\n    return `typeof ${this.value.toString()}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      value: this.value\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\nimport SymbolLiteralType from './SymbolLiteralType';\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {IdentifierPath} from '../Validation';\n\nexport default class SymbolType extends Type {\n  typeName: string = 'SymbolType';\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    // @flowIssue 252\n    if (typeof input === 'symbol') {\n      return false;\n    }\n    else {\n      validation.addError(path, this, getErrorMessage('ERR_EXPECT_SYMBOL'));\n      return true;\n    }\n  }\n\n  accepts (input: any): boolean {\n    return typeof input === 'symbol';\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof SymbolLiteralType) {\n      return 1;\n    }\n    else if (input instanceof SymbolType) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString () {\n    return 'Symbol';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\nimport type Validation, {IdentifierPath} from '../Validation';\nimport getErrorMessage from \"../getErrorMessage\";\n\n\n/**\n * # ThisType\n * Captures a reference to a particular instance of a class or a value,\n * and uses that value to perform an identity check.\n * In the case that `this` is undefined, any value will be permitted.\n */\nexport default class ThisType<T> extends Type {\n  typeName: string = 'ThisType';\n\n  recorded: ? T;\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    const {recorded} = this;\n    if (input === recorded) {\n      return false;\n    }\n    else if (typeof recorded === 'function' && input instanceof recorded) {\n      return false;\n    }\n    else if (recorded != null) {\n      validation.addError(path, this, getErrorMessage('ERR_EXPECT_THIS'));\n      return true;\n    }\n    else {\n      return false;\n    }\n  }\n\n  accepts (input: any): boolean {\n    const {recorded} = this;\n    if (input === recorded) {\n      return true;\n    }\n    else if (typeof recorded === 'function' && input instanceof recorded) {\n      return true;\n    }\n    else if (recorded != null) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof ThisType)) {\n      return -1;\n    }\n    else if (input.recorded && this.recorded) {\n      return input.recorded === this.recorded ? 0 : -1;\n    }\n    else if (this.recorded) {\n      return 0;\n    }\n    else {\n      return 1;\n    }\n  }\n\n  /**\n   * Get the inner type.\n   */\n  unwrap (): Type<T> {\n    return this;\n  }\n\n  toString (withBinding?: boolean): string {\n    return 'this';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n    };\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport type {TypeRevealer} from './';\nimport type Validation, {IdentifierPath} from '../Validation';\n\nimport TypeParameterApplication from './TypeParameterApplication';\n\nconst warnedInstances = new WeakSet();\n\nexport default class TypeBox<T: any> extends Type {\n  typeName: string = 'TypeBox';\n\n  reveal: TypeRevealer<T>;\n\n  get name (): ? string {\n    return (this.type: any).name;\n  }\n\n  get type (): Type<T> {\n    const {reveal} = this;\n    const type = reveal();\n    if (!type) {\n      if (!warnedInstances.has(this)) {\n        this.context.emitWarningMessage('Failed to reveal boxed type.');\n        warnedInstances.add(this);\n      }\n      return this.context.mixed();\n    }\n    else if (!(type instanceof Type)) {\n      // we got a boxed reference to something like a class\n      return this.context.ref(type);\n    }\n    return type;\n  }\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    return this.type.collectErrors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    return this.type.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.type, input);\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this.type;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return this.type.unwrap();\n  }\n\n  toString (): string {\n    return this.type.toString();\n  }\n\n  toJSON () {\n    return this.type.toJSON();\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\nimport type Validation, {IdentifierPath} from '../Validation';\n\nimport TypeParameterApplication from './TypeParameterApplication';\nimport compareTypes from '../compareTypes';\n\nconst warnedMissing = {};\n\nexport default class TypeReference<T: any> extends Type {\n  typeName: string = 'TypeReference';\n  name: string;\n\n  get type (): Type<T> {\n    const {context, name} = this;\n    const type = context.get(name);\n    if (!type) {\n      if (!warnedMissing[name]) {\n        context.emitWarningMessage(`Cannot resolve type: ${name}`);\n        warnedMissing[name] = true;\n      }\n      return (context.any(): any);\n    }\n    return type;\n  }\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    return this.type.collectErrors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    return this.type.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.type, input);\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return (this.type.unwrap(): any);\n  }\n\n  toString (): string {\n    return this.name;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      name: this.name\n    };\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport type {TypeRevealer} from './';\nimport type Validation, {IdentifierPath} from '../Validation';\nimport type ObjectTypeProperty from './ObjectTypeProperty';\n\nimport TypeParameterApplication from './TypeParameterApplication';\n\nconst warnedInstances = new WeakSet();\n\nconst RevealedValue = Symbol('RevealedValue');\n\nexport default class TypeTDZ<T: any> extends Type {\n  typeName: string = 'TypeTDZ';\n\n  reveal: TypeRevealer<T>;\n\n  // @flowIssue 252\n  [RevealedValue]: ? Type<T> = undefined;\n\n  get name (): ? string {\n    return (getRevealed(this): any).name;\n  }\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    return getRevealed(this).collectErrors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    return getRevealed(this).accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(getRevealed(this), input);\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = getRevealed(this);\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return getRevealed(this).unwrap();\n  }\n\n  hasProperty (name: string): boolean {\n    const inner = this.unwrap();\n    if (inner && typeof inner.hasProperty === 'function') {\n      return inner.hasProperty(name);\n    }\n    else {\n      return false;\n    }\n  }\n\n  getProperty (name: string): ? ObjectTypeProperty<any> {\n    const inner = this.unwrap();\n    if (inner && typeof inner.getProperty === 'function') {\n      return inner.getProperty(name);\n    }\n  }\n\n  toString (): string {\n    return getRevealed(this).toString();\n  }\n\n  toJSON () {\n    return getRevealed(this).toJSON();\n  }\n}\n\nfunction getRevealed <T: any> (container: TypeTDZ<T>): Type<T> {\n  const existing = (container: $FlowIssue<252>)[RevealedValue];\n  if (existing) {\n    return existing;\n  }\n  else {\n    const {reveal} = container;\n    const type = reveal();\n    if (!type) {\n      if (!warnedInstances.has(container)) {\n        container.context.emitWarningMessage('Failed to reveal type in Temporal Dead Zone.');\n        warnedInstances.add(container);\n      }\n      return container.context.mixed();\n    }\n    else if (!(type instanceof Type)) {\n      // we got a boxed reference to something like a class\n      return container.context.ref(type);\n    }\n    return type;\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {IdentifierPath} from '../Validation';\n\nimport compareTypes from '../compareTypes';\n\nexport default class UnionType<T> extends Type {\n  typeName: string = 'UnionType';\n  types: Type<T>[] = [];\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    const {types} = this;\n    const {length} = types;\n    for (let i = 0; i < length; i++) {\n      const type = types[i];\n      if (type.accepts(input)) {\n        return false;\n      }\n    }\n    validation.addError(path, this, getErrorMessage('ERR_NO_UNION', this.toString()));\n    return true;\n  }\n\n  accepts (input: any): boolean {\n    const {types} = this;\n    const {length} = types;\n    for (let i = 0; i < length; i++) {\n      const type = types[i];\n      if (type.accepts(input)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const types = this.types;\n    if (input instanceof UnionType) {\n      const inputTypes = input.types;\n      let identicalCount = 0;\n      loop: for (let i = 0; i < types.length; i++) {\n        const type = types[i];\n        for (let j = 0; j < inputTypes.length; j++) {\n          const result = compareTypes(type, inputTypes[i]);\n          if (result === 0) {\n            identicalCount++;\n            continue loop;\n          }\n          else if (result === 1) {\n            continue loop;\n          }\n        }\n        // if we got this far then nothing accepted this type.\n        return -1;\n      }\n\n      if (identicalCount === types.length) {\n        return 0;\n      }\n      else {\n        return 1;\n      }\n    }\n    else {\n      for (let i = 0; i < types.length; i++) {\n        const type = types[i];\n        if (compareTypes(type, input) >= 0) {\n          return 1;\n        }\n      }\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return this.types.join(' | ');\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      types: this.types\n    };\n  }\n}","/* @flow */\n\nimport primitiveTypes from './primitiveTypes';\n\nimport type TypeContext from './TypeContext';\n\nimport {\n  NullLiteralType,\n  NumberType,\n  BooleanType,\n  SymbolType,\n  StringType,\n  ExistentialType,\n  AnyType,\n  MixedType,\n  EmptyType,\n  VoidType\n} from './types';\n\n\nexport default function registerPrimitiveTypes (t: TypeContext): TypeContext {\n  primitiveTypes.null = Object.freeze(new NullLiteralType(t));\n  primitiveTypes.empty = Object.freeze(new EmptyType(t));\n  primitiveTypes.number = Object.freeze(new NumberType(t));\n  primitiveTypes.boolean = Object.freeze(new BooleanType(t));\n  primitiveTypes.string = Object.freeze(new StringType(t));\n  primitiveTypes.symbol = Object.freeze(new SymbolType(t));\n  primitiveTypes.any = Object.freeze(new AnyType(t));\n  primitiveTypes.mixed = Object.freeze(new MixedType(t));\n  primitiveTypes.void = Object.freeze(new VoidType(t));\n  primitiveTypes.existential = Object.freeze(new ExistentialType(t));\n  return t;\n}","/* @flow */\nimport getErrorMessage from './getErrorMessage';\n\nimport invariant from './invariant';\n\nimport {Type} from './types';\n\nimport type TypeContext from './TypeContext';\nimport type Validation, {IdentifierPath} from './Validation';\n\nexport default function registerBuiltinTypeConstructors (t: TypeContext): TypeContext {\n\n  t.declareTypeConstructor({\n    name: 'Date',\n    impl: Date,\n    typeName: 'DateType',\n    collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n      if (!(input instanceof Date)) {\n        validation.addError(path, this, getErrorMessage('ERR_EXPECT_INSTANCEOF', Date));\n        return true;\n      }\n      else if (isNaN(input.getTime())) {\n        validation.addError(path, this, getErrorMessage('ERR_INVALID_DATE'));\n        return true;\n      }\n      else {\n        return false;\n      }\n    },\n    accepts (input): boolean {\n      return input instanceof Date && !isNaN(input.getTime());\n    },\n    inferTypeParameters (input: Date): Type<any>[] {\n      return [];\n    }\n  });\n\n  t.declareTypeConstructor({\n    name: 'Promise',\n    impl: Promise,\n    typeName: 'PromiseType',\n    collectErrors (validation: Validation<any>, path: IdentifierPath, input: any, futureType: Type<any>): boolean {\n      const {context} = this;\n      if (!context.checkPredicate('Promise', input)) {\n        validation.addError(path, this, getErrorMessage('ERR_EXPECT_PROMISE', futureType));\n        return true;\n      }\n      return false;\n    },\n    accepts (input): boolean {\n      const {context} = this;\n      return context.checkPredicate('Promise', input);\n    },\n    inferTypeParameters (input: any): Type<any>[] {\n      return [];\n    }\n  });\n\n  t.declareTypeConstructor({\n    name: 'Map',\n    impl: Map,\n    typeName: 'MapType',\n    collectErrors (validation: Validation<any>, path: IdentifierPath, input: any, keyType: Type<any>, valueType?: Type<any>): boolean {\n      invariant(valueType, 'Must specify two type parameters.');\n      const {context} = this;\n      if (!context.checkPredicate('Map', input)) {\n        validation.addError(path, this, getErrorMessage('ERR_EXPECT_INSTANCEOF', 'Map'));\n        return true;\n      }\n      let hasErrors = false;\n      for (const [key, value] of input) {\n        if (!keyType.accepts(key)) {\n          validation.addError(path, this, getErrorMessage('ERR_EXPECT_KEY_TYPE', keyType));\n          hasErrors = true;\n        }\n        if (valueType.collectErrors(validation, path.concat(key), value)) {\n          hasErrors = true;\n        }\n      }\n      return hasErrors;\n    },\n    accepts (input, keyType: Type<any>, valueType: Type<any>): boolean {\n      const {context} = this;\n      if (!context.checkPredicate('Map', input)) {\n        return false;\n      }\n      for (const [key, value] of input) {\n        if (!keyType.accepts(key) || !valueType.accepts(value)) {\n          return false;\n        }\n      }\n      return true;\n    },\n    inferTypeParameters (input: Map<*, *>): Type<any>[] {\n      const keyTypes = [];\n      const valueTypes = [];\n      loop: for (const [key, value] of input) {\n        findKey: {\n          for (let i = 0; i < keyTypes.length; i++) {\n            const type = keyTypes[i];\n            if (type.accepts(key)) {\n              break findKey;\n            }\n          }\n          keyTypes.push(t.typeOf(key));\n        }\n\n        for (let i = 0; i < valueTypes.length; i++) {\n          const type = valueTypes[i];\n          if (type.accepts(value)) {\n            continue loop;\n          }\n        }\n        valueTypes.push(t.typeOf(value));\n      }\n      const typeInstances = [];\n\n      if (keyTypes.length === 0) {\n        typeInstances.push(t.existential());\n      }\n      else if (keyTypes.length === 1) {\n        typeInstances.push(keyTypes[0]);\n      }\n      else {\n        typeInstances.push(t.union(...keyTypes));\n      }\n\n      if (valueTypes.length === 0) {\n        typeInstances.push(t.existential());\n      }\n      else if (valueTypes.length === 1) {\n        typeInstances.push(valueTypes[0]);\n      }\n      else {\n        typeInstances.push(t.union(...valueTypes));\n      }\n\n      return typeInstances;\n    }\n  });\n\n  t.declareTypeConstructor({\n    name: 'Set',\n    impl: Set,\n    typeName: 'SetType',\n    collectErrors (validation: Validation<any>, path: IdentifierPath, input: any, valueType: Type<any>): boolean {\n      const {context} = this;\n      if (!context.checkPredicate('Set', input)) {\n        validation.addError(path, this, getErrorMessage('ERR_EXPECT_INSTANCEOF', 'Set'));\n        return true;\n      }\n      let hasErrors = false;\n      for (const value of input) {\n        if (valueType.collectErrors(validation, path, value)) {\n          hasErrors = true;\n        }\n      }\n      return hasErrors;\n    },\n    accepts (input, valueType) {\n      const {context} = this;\n      if (!context.checkPredicate('Set', input)) {\n        return false;\n      }\n      for (const value of input) {\n        if (!valueType.accepts(value)) {\n          return false;\n        }\n      }\n      return true;\n    },\n    inferTypeParameters (input: Set<*>): Type<any>[] {\n      const valueTypes = [];\n      loop: for (const value of input) {\n        for (let i = 0; i < valueTypes.length; i++) {\n          const type = valueTypes[i];\n          if (type.accepts(value)) {\n            continue loop;\n          }\n        }\n        valueTypes.push(t.typeOf(value));\n      }\n      if (valueTypes.length === 0) {\n        return [t.existential()];\n      }\n      else if (valueTypes.length === 1) {\n        return [valueTypes[0]];\n      }\n      else {\n        return [t.union(...valueTypes)];\n      }\n    }\n  });\n\n  return t;\n}","/* @flow */\n\nimport type TypeContext from './TypeContext';\n\nexport default function registerTypePredicates (context: TypeContext) {\n  context.setPredicate('Array', (input: any) => Array.isArray(input));\n  context.setPredicate('Map', (input: any) => input instanceof Map);\n  context.setPredicate('Set', (input: any) => input instanceof Set);\n  context.setPredicate('Promise', (input: any) => {\n    if (input instanceof Promise) {\n      return true;\n    }\n    else if (input !== null && typeof input === 'object' && typeof input.then === 'function') {\n      return input.then.length >= 2;\n    }\n    else {\n      return false;\n    }\n  });\n}","/* @flow */\n\nimport type TypeContext from './TypeContext';\n\nimport type {\n  Type,\n  ArrayType,\n  ObjectType\n} from './types';\n\ntype Inferred = Map<Object, Type<any>>;\n\nexport class TypeInferer {\n  context: TypeContext;\n\n  constructor (context: TypeContext) {\n    this.context = context;\n  }\n\n  infer <T> (input: T): Type<T> {\n    const primitive = this.inferPrimitive(input);\n    if (primitive) {\n      return primitive;\n    }\n    const inferred = new Map();\n    return this.inferComplex(input, inferred);\n  }\n\n  inferInternal <T> (input: T, inferred: Inferred): Type<T> {\n    const primitive = this.inferPrimitive(input);\n    if (primitive) {\n      return primitive;\n    }\n    return this.inferComplex(input, inferred);\n  }\n\n  inferPrimitive <T> (input: T): ? Type<T> {\n    const {context} = this;\n    if (input === null) {\n      return (context.null(): any);\n    }\n    else if (input === undefined) {\n      return (context.void(): any);\n    }\n    else if (typeof input === 'number') {\n      return (context.number(): any);\n    }\n    else if (typeof input === 'boolean') {\n      return (context.boolean(): any);\n    }\n    else if (typeof input === 'string') {\n      return (context.string(): any);\n    }\n    // @flowIssue 252\n    else if (typeof input === 'symbol') {\n      return context.symbol((input: any));\n    }\n    else {\n      return undefined;\n    }\n  }\n\n  inferComplex <T> (input: T, inferred: Inferred): Type<T> {\n    const {context} = this;\n\n    if (typeof input === 'function') {\n      return (this.inferFunction(input, inferred): any);\n    }\n    else if (input !== null && typeof input === 'object') {\n      return (this.inferObject(input, inferred): any);\n    }\n    else {\n      return (context.any(): any);\n    }\n  }\n\n  inferFunction <T: Function> (input: T, inferred: Inferred): Type<T> {\n    const {context} = this;\n    const {length} = input;\n    const body = new Array(length + 1);\n    for (let i = 0; i < length; i++) {\n      body[i] = context.param(\n        String.fromCharCode(97 + i),\n        context.existential()\n      );\n    }\n    body[length] = context.return(context.existential());\n    return (context.fn(...body): any);\n  }\n\n  inferObject <T: Object> (input: T, inferred: Inferred): Type<T> {\n    const existing = inferred.get(input);\n    if (existing) {\n      return existing;\n    }\n    const {context} = this;\n    let type;\n\n    // Temporarily create a box for this type to catch cyclical references.\n    // Nested references to this object will receive the boxed type.\n    const box = context.box(() => type);\n    inferred.set(input, box);\n\n    if (context.checkPredicate('Array', input)) {\n      type = this.inferArray((input: any), inferred);\n    }\n    else if (!(input instanceof Object)) {\n      type = this.inferDict(input, inferred);\n    }\n    else if (input.constructor !== Object) {\n      const handler = context.getTypeConstructor(input.constructor);\n      if (handler) {\n        const typeParameters = handler.inferTypeParameters(input);\n        type = handler.apply(...typeParameters);\n      }\n      else {\n        type = context.ref(input.constructor);\n      }\n    }\n    else {\n      const body = [];\n      for (const key in input) { // eslint-disable-line\n        const value = input[key];\n        body.push(context.property(key, this.inferInternal(value, inferred)));\n      }\n      type = context.object(...body);\n    }\n\n    // Overwrite the box with the real value.\n    inferred.set(input, type);\n    return (type: any);\n  }\n\n  inferDict <T: Object> (input: T, inferred: Inferred): ObjectType<T> {\n    const numericIndexers = [];\n    const stringIndexers = [];\n    loop: for (const key in input) { // eslint-disable-line\n      const value = input[key];\n      const types = isNaN(+key) ? stringIndexers : numericIndexers;\n      for (let i = 0; i < types.length; i++) {\n        const type = types[i];\n        if (type.accepts(value)) {\n          continue loop;\n        }\n      }\n      types.push(this.inferInternal(value, inferred));\n    }\n\n    const {context} = this;\n    const body = [];\n    if (numericIndexers.length === 1) {\n      body.push(\n        context.indexer(\n          'index',\n          context.number(),\n          numericIndexers[0]\n        )\n      );\n    }\n    else if (numericIndexers.length > 1) {\n      body.push(\n        context.indexer(\n          'index',\n          context.number(),\n          context.union(...numericIndexers)\n        )\n      );\n    }\n\n    if (stringIndexers.length === 1) {\n      body.push(\n        context.indexer(\n          'key',\n          context.string(),\n          stringIndexers[0]\n        )\n      );\n    }\n    else if (stringIndexers.length > 1) {\n      body.push(\n        context.indexer(\n          'key',\n          context.string(),\n          context.union(...stringIndexers)\n        )\n      );\n    }\n\n    return context.object(...body);\n  }\n\n  inferArray <T> (input: T[], inferred: Inferred): ArrayType<T> {\n    const {context} = this;\n    const types = [];\n    const values = [];\n    const {length} = input;\n    loop: for (let i = 0; i < length; i++) {\n      const item = input[i];\n      const inferredType = this.inferInternal(item, inferred);\n      for (let j = 0; j < types.length; j++) {\n        const type = types[j];\n        if (type.accepts(item) && inferredType.accepts(values[j])) {\n          continue loop;\n        }\n      }\n      types.push(inferredType);\n      values.push(item);\n    }\n    if (types.length === 0) {\n      return (context.array(context.any()): any);\n    }\n    else if (types.length === 1) {\n      return context.array(types[0]);\n    }\n    else {\n      return context.array(context.union(...types));\n    }\n  }\n\n}\n\nexport default TypeInferer;","/* @flow */\n\nimport makeError from './makeError';\n\nimport type ObjectType from './types/ObjectType';\n\nexport type PropType<T: {}> = (props: T, propName: string, componentName: string) => ? Error;\n\nexport type PropTypeDict<T: {}> = $ObjMap<T, <V>(v: V) => PropType<V>>;\n\nexport default function makeReactPropTypes <T: {}> (objectType: ObjectType<T>): PropTypeDict<T> {\n  const output = {};\n  for (const property of objectType.properties) {\n    output[property.key] = (props, propName, componentName) => {\n      return makeError(property, props);\n    };\n  }\n  return output;\n}","/* @flow */\nimport {stringifyPath, resolvePath} from '../Validation';\n\nimport type Validation from '../Validation';\n\nconst delimiter = '\\n-------------------------------------------------\\n\\n';\n\nexport default function makeWarningMessage <T> (validation: Validation<T>): ? string {\n  if (!validation.hasErrors()) {\n    return;\n  }\n  const {input, context} = validation;\n  const collected = [];\n  for (const [path, message, expectedType] of validation.errors) {\n    const expected = expectedType ? expectedType.toString() : \"*\";\n    const actual = context.typeOf(resolvePath(input, path)).toString();\n\n    const field = stringifyPath(validation.path.concat(path));\n\n\n    collected.push(\n      `${field} ${message}\\n\\nExpected: ${expected}\\n\\nActual: ${actual}\\n`\n    );\n  }\n  return `Warning: ${collected.join(delimiter)}`;\n}\n","/* @flow */\n\nimport UnionType from './types/UnionType';\nimport compareTypes from './compareTypes';\n\nimport type TypeContext from './TypeContext';\nimport type Type from './types/Type';\n\n\nexport default function makeUnion <T> (context: TypeContext, types: Type<T>[]): UnionType<T> {\n  const length = types.length;\n  const merged = [];\n  for (let i = 0; i < length; i++) {\n    const type = types[i];\n    if (type instanceof UnionType) {\n      mergeUnionTypes(merged, type.types);\n    }\n    else {\n      merged.push(type);\n    }\n  }\n  const union = new UnionType(context);\n  union.types = merged;\n  return union;\n}\n\nfunction mergeUnionTypes (aTypes: Type<any>[], bTypes: Type<any>[]): void {\n  loop: for (let i = 0; i < bTypes.length; i++) {\n    const bType = bTypes[i];\n    for (let j = 0; j < aTypes.length; j++) {\n      const aType = aTypes[j];\n      if (compareTypes(aType, bType) !== -1) {\n        continue loop;\n      }\n    }\n    aTypes.push(bType);\n  }\n}","/* @flow */\n\nimport type Type from './types/Type';\n\ntype ValueDescriptor<T> = {\n  writable: boolean;\n  initializer?: () => T;\n  enumerable: boolean;\n  configurable: boolean;\n};\n\ntype AccessorDescriptor<T> = {\n  get: () => ? T;\n  set: (value: T) => void;\n  enumerable: boolean;\n  configurable: boolean;\n};\n\nexport type Descriptor<T>\n = AccessorDescriptor<T>\n | ValueDescriptor<T>\n ;\n\ntype TypeSource<T>\n = (() => Type<T>)\n | Type<T>\n ;\n\nexport function makePropertyDescriptor <O: {} | Function, T> (typeSource: TypeSource<T>, input: O, propertyName: string, descriptor: Descriptor<T>, shouldAssert: boolean): ? Descriptor<T> {\n  if (typeof descriptor.get === 'function' && typeof descriptor.set === 'function') {\n    return augmentExistingAccessors(typeSource, input, propertyName, (descriptor: $FlowIssue<AccessorDescriptor<T>>), shouldAssert);\n  }\n  else {\n    return propertyToAccessor(typeSource, input, propertyName, (descriptor: $FlowIssue<ValueDescriptor<T>>), shouldAssert);\n  }\n}\n\nfunction makePropertyName (name: string): string {\n  return `_flowRuntime$${name}`;\n}\n\nfunction getClassName (input: Function | Object): string {\n  if (typeof input === 'function') {\n    return input.name || '[Class anonymous]';\n  }\n  else if (typeof input.constructor === 'function') {\n    return getClassName(input.constructor);\n  }\n  else {\n    return '[Class anonymous]';\n  }\n}\n\nfunction resolveType <T> (receiver: any, typeSource: TypeSource<T>): Type<T> {\n  if (typeof typeSource === 'function') {\n    return typeSource.call(receiver);\n  }\n  else {\n    return typeSource;\n  }\n}\n\nfunction propertyToAccessor <O: {}, T> (typeSource: TypeSource<T>, input: O, propertyName: string, descriptor: ValueDescriptor<T>, shouldAssert: boolean): AccessorDescriptor<T> {\n  const safeName = makePropertyName(propertyName);\n  const className = getClassName(input);\n  const {initializer, writable, ...config} = descriptor; // eslint-disable-line no-unused-vars\n\n  const propertyPath = [className, propertyName];\n\n  return {\n    ...config,\n    type: 'accessor',\n    get (): ? T {\n      if (safeName in this) {\n        return (this: any)[safeName];\n      }\n      else if (initializer) {\n        const type = resolveType(this, typeSource);\n        const value = initializer.call(this);\n        const context = type.context;\n        context.check(type, value, 'Default value for property', propertyPath);\n        Object.defineProperty(this, safeName, {\n          writable: true,\n          value: value\n        });\n        return value;\n      }\n      else {\n        Object.defineProperty(this, safeName, {\n          writable: true,\n          value: undefined\n        });\n      }\n    },\n    set (value: T): void {\n      const type = resolveType(this, typeSource);\n      const context = type.context;\n      if (shouldAssert) {\n        context.assert(type, value, 'Property', propertyPath);\n      }\n      else {\n        context.warn(type, value, 'Property', propertyPath);\n      }\n      if (safeName in this) {\n        this[safeName] = value;\n      }\n      else {\n        Object.defineProperty(this, safeName, {\n          writable: true,\n          value: value\n        });\n      }\n    }\n  };\n}\n\nfunction augmentExistingAccessors <O: {}, T> (typeSource: TypeSource<T>, input: O, propertyName: string, descriptor: AccessorDescriptor<T>, shouldAssert: boolean) {\n\n  const className = getClassName(input);\n  const propertyPath = [className, propertyName];\n\n  const originalSetter = descriptor.set;\n\n  descriptor.set = function set (value: T): void {\n    const type = resolveType(this, typeSource);\n    const context = type.context;\n    if (shouldAssert) {\n      context.assert(type, value, 'Property', propertyPath);\n    }\n    else {\n      context.warn(type, value, 'Property', propertyPath);\n    }\n    originalSetter.call(this, value);\n  };\n\n}\n\n","/* @flow */\n\nimport Type from './types/Type';\n\nimport {TypeSymbol} from './symbols';\n\nexport type Decorator<T> = (input: T) => T;\n\ndeclare function annotateValue <T> (type: Type<T>): Decorator<T>;\ndeclare function annotateValue <T> (input: T, type: Type<T>): T; // eslint-disable-line no-redeclare\n\nexport default function annotateValue (input, type?) { // eslint-disable-line no-redeclare\n  if (type instanceof Type) {\n    input[TypeSymbol] = type;\n    return input;\n  }\n  else {\n    const type = input;\n    return (input) => {\n      input[TypeSymbol] = type;\n      return input;\n    };\n  }\n}","/* @flow */\n\nimport Type from '../types/Type';\n\nexport default class Declaration extends Type {\n  name: string;\n}","/* @flow */\n\nimport Declaration from './Declaration';\nimport compareTypes from '../compareTypes';\n\nimport type {Type, TypeConstraint} from '../types';\n\nimport type Validation, {IdentifierPath} from '../Validation';\n\nimport {addConstraints, collectConstraintErrors, constraintsAccept} from '../typeConstraints';\n\nexport default class VarDeclaration<T> extends Declaration {\n  typeName: string = 'VarDeclaration';\n\n  name: string;\n  type: Type<T>;\n  constraints: TypeConstraint[] = [];\n\n  addConstraint (...constraints: TypeConstraint[]): VarDeclaration<T> {\n    addConstraints(this, ...constraints);\n    return this;\n  }\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    const {type} = this;\n    let hasErrors = false;\n    if (type.collectErrors(validation, path, input)) {\n      hasErrors = true;\n    }\n    else if (collectConstraintErrors(this, validation, path, input)) {\n      hasErrors = true;\n    }\n    return hasErrors;\n  }\n\n  accepts (input: any): boolean {\n    const {type} = this;\n    if (!type.accepts(input)) {\n      return false;\n    }\n    else if (!constraintsAccept(this, input)) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.type, input);\n  }\n\n  unwrap () {\n    return this.type.unwrap();\n  }\n\n  toString (): string {\n    return `declare var ${this.name}: ${this.type.toString()};`;\n  }\n}","/* @flow */\n\nimport Declaration from './Declaration';\nimport compareTypes from '../compareTypes';\n\nimport type {\n  Type,\n  TypeAlias,\n  ParameterizedTypeAlias,\n  TypeConstraint,\n  TypeParameterApplication,\n  ObjectTypeProperty\n} from '../types';\n\nimport type Validation, {IdentifierPath} from '../Validation';\n\nexport default class TypeDeclaration<T> extends Declaration {\n  typeName: string = 'TypeDeclaration';\n\n  get type (): Type<T> {\n    return this.typeAlias.type;\n  }\n\n  typeAlias: TypeAlias<T> | ParameterizedTypeAlias<T>;\n\n  addConstraint (...constraints: TypeConstraint[]): TypeDeclaration<T> {\n    this.typeAlias.addConstraint(...constraints);\n    return this;\n  }\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    return this.typeAlias.collectErrors(validation, path, input);\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<X, T> {\n    return this.typeAlias.apply(...typeInstances);\n  }\n\n  accepts (input: any): boolean {\n    return this.typeAlias.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.typeAlias, input);\n  }\n\n  hasProperty (name: string, ...typeInstances: Type<any>[]): boolean {\n    return this.typeAlias.hasProperty(name, ...typeInstances);\n  }\n\n  getProperty (name: string, ...typeInstances: Type<any>[]): ? ObjectTypeProperty<any> {\n    return this.typeAlias.getProperty(name, ...typeInstances);\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (...typeInstances: Type<any>[]): Type<any> {\n    return this.typeAlias.unwrap(...typeInstances);\n  }\n\n  toString (): string {\n    return `declare ${this.typeAlias.toString(true)};`;\n  }\n}","/* @flow */\n\nimport Declaration from './Declaration';\n\nimport type {Type} from '../types';\nimport type ModuleExportsDeclaration from './ModuleExportsDeclaration';\n\nimport type TypeContext from '../TypeContext';\n\nimport type Validation, {IdentifierPath} from '../Validation';\n\nexport type DeclarationDict = {\n  [name: string]: Type<any>;\n};\n\nexport type ModuleDeclarationDict = {\n  [name: string]: ModuleDeclaration;\n};\n\nimport {NameRegistrySymbol, ModuleRegistrySymbol} from '../symbols';\n\nexport default class ModuleDeclaration extends Declaration {\n  typeName: string = 'ModuleDeclaration';\n\n\n  name: string;\n  innerContext: TypeContext;\n  moduleExports: ? ModuleExportsDeclaration<any>;\n\n  get moduleType (): 'commonjs' | 'es6' {\n    if (this.moduleExports) {\n      return 'commonjs';\n    }\n    else {\n      return 'es6';\n    }\n  }\n\n  get isCommonJS (): boolean {\n    return this.moduleExports ? true : false;\n  }\n\n  get isES6 (): boolean {\n    return this.moduleExports ? false : true;\n  }\n\n  get declarations (): DeclarationDict {\n    const {innerContext} = this;\n    return (innerContext: $FlowIssue<252>)[NameRegistrySymbol];\n  }\n\n  get modules (): ModuleDeclarationDict {\n    const {innerContext} = this;\n    return (innerContext: $FlowIssue<252>)[ModuleRegistrySymbol];\n  }\n\n  get (name: string): ? Type<any> {\n    const {moduleExports} = this;\n    if (moduleExports) {\n      const exporting = moduleExports.unwrap();\n      if (typeof exporting.getProperty === 'function') {\n        const prop = exporting.getProperty(name);\n        if (prop) {\n          return prop.unwrap();\n        }\n      }\n    }\n    else {\n      const declaration = this.declarations[name];\n      if (declaration) {\n        return declaration.unwrap();\n      }\n    }\n  }\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    // Can't validate a module directly.\n    // @todo should this throw?\n    return false;\n  }\n\n  import (moduleName: string): ? ModuleDeclaration {\n    if (/^\\.\\//.test(moduleName)) {\n      moduleName = `${this.name}${moduleName.slice(1)}`;\n    }\n    return this.innerContext.import(moduleName);\n  }\n\n  toString (): string {\n\n    const {name, declarations, modules, moduleExports} = this;\n    const body = [];\n    for (const name in declarations) { // eslint-disable-line guard-for-in\n      const declaration = declarations[name];\n      body.push(declaration.toString(true));\n    }\n    if (modules) {\n      for (const name in modules) { // eslint-disable-line guard-for-in\n        const module = modules[name];\n        body.push(module.toString());\n      }\n    }\n    if (moduleExports) {\n      body.push(moduleExports.toString());\n    }\n    return `declare module \"${name}\" {\\n${indent(body.join('\\n\\n'))}}`;\n  }\n}\n\n\nfunction indent (input: string): string {\n  const lines = input.split('\\n');\n  const {length} = lines;\n  for (let i = 0; i < length; i++) {\n    lines[i] = `  ${lines[i]}`;\n  }\n  return lines.join('\\n');\n}","/* @flow */\n\nimport Declaration from './Declaration';\n\nimport type {Type} from '../types';\n\nimport type Validation, {IdentifierPath} from '../Validation';\n\nexport default class ModuleExports<T> extends Declaration {\n  typeName: string = 'ModuleExports';\n\n  type: Type<T>;\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    return this.type.collectErrors(validation, path, input);\n  }\n\n  unwrap () {\n    return this.type.unwrap();\n  }\n\n  toString (): string {\n    return `declare module.exports: ${this.type.toString()};`;\n  }\n}","/* @flow */\n\nimport Declaration from './Declaration';\nimport TypeParameterApplication from '../types/TypeParameterApplication';\nimport getErrorMessage from \"../getErrorMessage\";\nimport compareTypes from '../compareTypes';\n\nimport type {Type, ObjectType} from '../types';\n\nimport type {Property} from '../types/ObjectType';\n\nimport type Validation, {IdentifierPath} from '../Validation';\n\nexport default class ClassDeclaration<O: {}> extends Declaration {\n  typeName: string = 'ClassDeclaration';\n\n  name: string;\n  superClass: ? Type<{}>;\n  body: ObjectType<O>;\n\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    const {body} = this;\n    const superClass = this.superClass && this.superClass.unwrap();\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      validation.addError(path, this, getErrorMessage('ERR_EXPECT_INSTANCEOF', this.name));\n      return true;\n    }\n    let hasSuperErrors = false;\n    if (superClass && superClass.collectErrors(validation, path, input)) {\n      // Clear any errors for properties we override in this class.\n      let didClear = false;\n      for (const property of body.properties) {\n        if (validation.clearError(path.concat(property.key))) {\n          didClear = true;\n        }\n      }\n      hasSuperErrors = didClear ? validation.hasErrors(path) : true;\n    }\n    if (body.collectErrors(validation, path, input)) {\n      return true;\n    }\n    return hasSuperErrors;\n  }\n\n  accepts (input: any): boolean {\n    const {body} = this;\n    const superClass = this.superClass && this.superClass.unwrap();\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      return false;\n    }\n    else if (superClass && !superClass.accepts(input)) {\n      return false;\n    }\n    else if (!body.accepts(input)) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.body, input);\n  }\n\n  /**\n   * Get a property with the given name, or undefined if it does not exist.\n   */\n  getProperty (key: string | number): ? Property<$Keys<O>, any> {\n    const {body, superClass} = this;\n    const prop = body.getProperty(key);\n    if (prop) {\n      return prop;\n    }\n    else if (superClass && typeof superClass.getProperty === 'function') {\n      return superClass.getProperty(key);\n    }\n  }\n\n  /**\n   * Determine whether a property with the given name exists.\n   */\n  hasProperty (key: string): boolean {\n    const {body, superClass} = this;\n    if (body.hasProperty(key)) {\n      return true;\n    }\n    else if (superClass && typeof superClass.hasProperty === 'function') {\n      return superClass.hasProperty(key);\n    }\n    else {\n      return false;\n    }\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<X, O> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  toString (withDeclaration?: boolean) {\n    const {name, superClass, body} = this;\n    const superClassName = superClass && ((typeof superClass.name === 'string' && superClass.name) || superClass.toString());\n    return `${withDeclaration ? 'declare ' : ''}class ${name}${superClassName ? ` extends ${superClassName}` : ''} ${body.toString()}`;\n  }\n}\n","/* @flow */\n\nimport Declaration from './Declaration';\nimport PartialType from '../types/PartialType';\nimport TypeParameterApplication from '../types/TypeParameterApplication';\nimport type {Type} from '../types';\n\nimport type Validation, {IdentifierPath} from '../Validation';\n\nimport type {ClassBodyCreator} from './';\n\nexport default class ParameterizedClassDeclaration<X, O: {}> extends Declaration {\n  typeName: string = 'ParameterizedClassDeclaration';\n  bodyCreator: ClassBodyCreator<X, O>;\n  name: string;\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any, ...typeInstances: Type<any>[]): boolean {\n    return getPartial(this, ...typeInstances).collectErrors(validation, path, input);\n  }\n\n  accepts (input: any, ...typeInstances: Type<any>[]): boolean {\n    return getPartial(this, ...typeInstances).accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return getPartial(this).compareWith(input);\n  }\n\n  unwrap (...typeInstances: Type<any>[]): Type<O> {\n    return getPartial(this, ...typeInstances).unwrap();\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<X, O> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  toString (withDeclaration?: boolean) {\n    return getPartial(this).toString(withDeclaration);\n  }\n\n  toJSON () {\n    return getPartial(this).toJSON();\n  }\n}\n\nfunction getPartial <X, O: {}> (parent: ParameterizedClassDeclaration<X, O>, ...typeInstances: Type<any>[]): PartialType<O> {\n\n  const {context, bodyCreator} = parent;\n  const partial = new PartialType(context);\n  const body = bodyCreator(partial);\n  if (Array.isArray(body)) {\n    partial.type = context.class(parent.name, ...body);\n  }\n  else {\n    partial.type = context.class(parent.name, body);\n  }\n\n  const {typeParameters} = partial;\n  const limit = Math.min(typeInstances.length, typeParameters.length);\n  for (let i = 0; i < limit; i++) {\n    const typeParameter = typeParameters[i];\n    const typeInstance = typeInstances[i];\n    if (typeParameter.bound && typeParameter.bound !== typeInstance) {\n      // if the type parameter is already bound we need to\n      // create an intersection type with this one.\n      typeParameter.bound = context.intersect(typeParameter.bound, typeInstance);\n    }\n    else {\n      typeParameter.bound = typeInstance;\n    }\n  }\n\n  return partial;\n}\n\n","/* @flow */\n\nimport Declaration from './Declaration';\n\nimport type {Type} from '../types';\n\nimport type Validation, {IdentifierPath} from '../Validation';\n\nexport default class ExtendsDeclaration<T> extends Declaration {\n  typeName: string = 'ExtendsDeclaration';\n\n  type: Type<T>;\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    return this.type.collectErrors(validation, path, input);\n  }\n\n  unwrap () {\n    return this.type.unwrap();\n  }\n\n  toString (withDeclaration?: boolean) {\n    const {type} = this;\n    if (withDeclaration) {\n      return `extends ${type.toString()}`;\n    }\n    else {\n      return type.toString();\n    }\n  }\n}","/* @flow */\n\nimport Type from '../types/Type';\nimport ObjectType from '../types/ObjectType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport invariant from '../invariant';\n\nimport type Validation, {IdentifierPath} from '../Validation';\n\n// If A and B are object types, $Diff<A,B> is the type of objects that have\n// properties defined in A, but not in B.\n// Properties that are defined in both A and B are allowed too.\n\nexport default class $DiffType<A: {}, B: {}> extends Type<$Diff<A, B>> {\n  typeName: string = '$DiffType';\n\n  aType: Type<A>;\n  bType: Type<B>;\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    let {aType, bType} = this;\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      validation.addError(path, this, getErrorMessage('ERR_EXPECT_OBJECT'));\n      return true;\n    }\n    aType = aType.unwrap();\n    bType = bType.unwrap();\n    invariant(aType instanceof ObjectType && bType instanceof ObjectType, 'Can only $Diff object types.');\n    let hasErrors = false;\n    const properties = aType.properties;\n    for (let i = 0; i < properties.length; i++) {\n      const property = properties[i];\n      if (bType.hasProperty(property.key)) {\n        continue;\n      }\n      if (property.collectErrors(validation, path.concat(property.key), input)) {\n        hasErrors = true;\n      }\n    }\n    return hasErrors;\n  }\n\n  accepts (input: any): boolean {\n    let {aType, bType} = this;\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      return false;\n    }\n    aType = aType.unwrap();\n    bType = bType.unwrap();\n    invariant(aType instanceof ObjectType && bType instanceof ObjectType, 'Can only $Diff object types.');\n    const properties = aType.properties;\n    for (let i = 0; i < properties.length; i++) {\n      const property = properties[i];\n      if (bType.hasProperty(property.key)) {\n        continue;\n      }\n      if (!property.accepts(input)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$Diff<A, B>> {\n    let {aType, bType} = this;\n    aType = aType.unwrap();\n    bType = bType.unwrap();\n    invariant(aType instanceof ObjectType && bType instanceof ObjectType, 'Can only $Diff object types.');\n    const properties = aType.properties;\n    const args = [];\n    for (let i = 0; i < properties.length; i++) {\n      const property = properties[i];\n      if (bType.hasProperty(property.key)) {\n        continue;\n      }\n      args.push(property);\n    }\n    return this.context.object(...args);\n  }\n\n  toString (): string {\n    return `$Diff<${this.aType.toString()}, ${this.bType.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      aType: this.aType,\n      bType: this.bType\n    };\n  }\n}","/* @flow */\n\nimport Type from '../types/Type';\n\nimport type Validation, {IdentifierPath} from '../Validation';\n\n// Any subtype of T\n\nexport default class $FlowFixMeType extends Type<any> {\n  typeName: string = '$FlowFixMeType';\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    return false;\n  }\n\n  accepts (input: any): boolean {\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return 1;\n  }\n\n  unwrap (): Type<any> {\n    return this;\n  }\n\n  toString (): string {\n    return '$FlowFixMe';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n    };\n  }\n}","/* @flow */\n\nimport Type from '../types/Type';\nimport ObjectType from '../types/ObjectType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport invariant from '../invariant';\nimport type Validation, {IdentifierPath} from '../Validation';\n\n// The set of keys of T.\n\nexport default class $KeysType<T: {}> extends Type<$Keys<T>> {\n  typeName: string = '$KeysType';\n\n  type: Type<T>;\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    const type = this.type.unwrap();\n    invariant(type instanceof ObjectType, 'Can only $Keys<T> object types.');\n\n    const properties = type.properties;\n    const length = properties.length;\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      if (input === property.key) {\n        return false;\n      }\n    }\n    const keys = new Array(length);\n    for (let i = 0; i < length; i++) {\n      keys[i] = properties[i].key;\n    }\n    validation.addError(path, this, getErrorMessage('ERR_NO_UNION', keys.join(' | ')));\n    return true;\n  }\n\n  accepts (input: any): boolean {\n    const type = this.type.unwrap();\n    invariant(type instanceof ObjectType, 'Can only $Keys<T> object types.');\n\n    const properties = type.properties;\n    const length = properties.length;\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      if (input === property.key) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$Keys<T>> {\n    const context = this.context;\n    const type = this.type.unwrap();\n    invariant(type instanceof ObjectType, 'Can only $Keys<T> object types.');\n\n    const properties = type.properties;\n    const length = properties.length;\n    const keys = new Array(length);\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      keys[i] = context.literal(property.key);\n    }\n    return this.context.union(...keys);\n  }\n\n  toString (): string {\n    return `$Keys<${this.type.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}","/* @flow */\n\nimport Type from '../types/Type';\nimport ObjectType from '../types/ObjectType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport invariant from '../invariant';\n\nimport ObjectTypeProperty from '../types/ObjectTypeProperty';\nimport FunctionType from '../types/FunctionType';\n\n\nimport type Validation, {IdentifierPath} from '../Validation';\n\ntype Mapper = <V: any, R: any> (v: V) => R;\n\n// Map over the keys and values in an object.\n\nexport default class $ObjMapiType<O: {}, M: Mapper> extends Type<$ObjMapi<O, M>> {\n  typeName: string = '$ObjMapiType';\n\n  object: Type<O>;\n  mapper: Type<M>;\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    let {object, mapper, context} = this;\n    const target = object.unwrap();\n    invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      validation.addError(path, this, getErrorMessage('ERR_EXPECT_OBJECT'));\n      return true;\n    }\n\n    let hasErrors = false;\n    for (const prop: ObjectTypeProperty<*, *> of target.properties) {\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      const returnType = applied.invoke(context.literal(prop.key), prop.value);\n\n      const value = input[prop.key];\n      if (returnType.collectErrors(validation, path.concat(prop.key), value)) {\n        hasErrors = true;\n      }\n    }\n\n    return hasErrors;\n  }\n\n  accepts (input: any): boolean {\n    let {object, mapper, context} = this;\n    const target = object.unwrap();\n    invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      return false;\n    }\n\n    for (const prop: ObjectTypeProperty<*, *> of target.properties) {\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      const returnType = applied.invoke(context.literal(prop.key), prop.value);\n\n      const value = input[prop.key];\n      if (!returnType.accepts(value)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$ObjMapi<O, M>> {\n    let {object, mapper, context} = this;\n    const target = object.unwrap();\n    invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n    const args = [];\n\n    for (const prop: ObjectTypeProperty<*, *> of target.properties) {\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      args.push(context.property(\n        prop.key,\n        applied.invoke(context.literal(prop.key), prop.value)\n      ));\n    }\n\n    return context.object(...args);\n  }\n\n  toString (): string {\n    return `$ObjMapi<${this.object.toString()}, ${this.mapper.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      object: this.object,\n      mapper: this.mapper\n    };\n  }\n}","/* @flow */\n\nimport Type from '../types/Type';\nimport ObjectType from '../types/ObjectType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport invariant from '../invariant';\n\nimport ObjectTypeProperty from '../types/ObjectTypeProperty';\nimport FunctionType from '../types/FunctionType';\n\n\nimport type Validation, {IdentifierPath} from '../Validation';\n\ntype Mapper = <V: any, R: any> (v: V) => R;\n\n// Map over the keys in an object.\n\nexport default class $ObjMapType<O: {}, M: Mapper> extends Type<$ObjMap<O, M>> {\n  typeName: string = '$ObjMapType';\n\n  object: Type<O>;\n  mapper: Type<M>;\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    let {object, mapper, context} = this;\n    const target = object.unwrap();\n    invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      validation.addError(path, this, getErrorMessage('ERR_EXPECT_OBJECT'));\n      return true;\n    }\n\n    let hasErrors = false;\n    for (const prop: ObjectTypeProperty<*, *> of target.properties) {\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      const returnType = applied.invoke(context.literal(prop.key));\n      const value = input[prop.key];\n      if (returnType.collectErrors(validation, path.concat(prop.key), value)) {\n        hasErrors = true;\n      }\n    }\n\n    return hasErrors;\n  }\n\n  accepts (input: any): boolean {\n    let {object, mapper, context} = this;\n    const target = object.unwrap();\n    invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      return false;\n    }\n\n    for (const prop: ObjectTypeProperty<*, *> of target.properties) {\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      const returnType = applied.invoke(context.literal(prop.key));\n\n      const value = input[prop.key];\n      if (!returnType.accepts(value)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$ObjMap<O, M>> {\n\n    let {object, mapper, context} = this;\n    const target = object.unwrap();\n    invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n    const args = [];\n\n    for (const prop: ObjectTypeProperty<*, *> of target.properties) {\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      args.push(context.property(\n        prop.key,\n        applied.invoke(context.literal(prop.key))\n      ));\n    }\n\n    return context.object(...args);\n  }\n\n  toString (): string {\n    return `$ObjMap<${this.object.toString()}, ${this.mapper.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      object: this.object,\n      mapper: this.mapper\n    };\n  }\n}","/* @flow */\n\nimport Type from '../types/Type';\nimport compareTypes from '../compareTypes';\nimport invariant from '../invariant';\nimport type Validation, {IdentifierPath} from '../Validation';\n\n// The type of the named object property\n\nexport default class $PropertyType<O: {}, P: string | number | Symbol> extends Type {\n  typeName: string = '$PropertyType';\n\n  object: Type<O>;\n\n  property: P;\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    return this.unwrap().collectErrors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    return this.unwrap().accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<*> {\n    const {object, property} = this;\n    const unwrapped = object.unwrap();\n    invariant(typeof unwrapped.getProperty === 'function', 'Can only use $PropertyType on Objects.');\n    return unwrapped.getProperty(property).unwrap();\n  }\n\n  toString (): string {\n    return `$PropertyType<${this.object.toString()}, ${String(this.property)}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      object: this.object,\n      property: this.property\n    };\n  }\n}","/* @flow */\n\nimport Type from '../types/Type';\nimport ObjectType from '../types/ObjectType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport invariant from '../invariant';\nimport type Validation, {IdentifierPath} from '../Validation';\n\n// An object of type $Shape<T> does not have to have all of the properties\n// that type T defines. But the types of the properties that it does have\n// must accepts the types of the same properties in T.\n\nexport default class $ShapeType<T> extends Type<$Shape<T>> {\n  typeName: string = '$ShapeType';\n\n  type: Type<T>;\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    let {type} = this;\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      validation.addError(path, this, getErrorMessage('ERR_EXPECT_OBJECT'));\n      return true;\n    }\n    type = type.unwrap();\n    invariant(typeof type.getProperty === 'function', 'Can only $Shape<T> object types.');\n\n    let hasErrors = false;\n    for (const key in input) { // eslint-disable-line guard-for-in\n      const property = type.getProperty(key);\n      if (!property) {\n        continue;\n      }\n      if (property.collectErrors(validation, path, input)) {\n        hasErrors = true;\n      }\n    }\n\n    return hasErrors;\n  }\n\n  accepts (input: any): boolean {\n    let {type} = this;\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      return false;\n    }\n    type = type.unwrap();\n    invariant(typeof type.getProperty === 'function', 'Can only $Shape<T> object types.');\n    for (const key in input) { // eslint-disable-line guard-for-in\n      const property = type.getProperty(key);\n      if (!property || !property.accepts(input)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$Shape<T>> {\n    let {type} = this;\n    type = type.unwrap();\n    const context = this.context;\n    invariant(type instanceof ObjectType, 'Can only $Shape<T> object types.');\n    const properties = type.properties;\n    const args = new Array(properties.length);\n    for (let i = 0; i < properties.length; i++) {\n      const property = properties[i];\n      args[i] = context.property(property.key, property.value, true);\n    }\n    return this.context.object(...args);\n  }\n\n  toString (): string {\n    return `$Shape<${this.type.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}","/* @flow */\n\nimport Type from '../types/Type';\nimport compareTypes from '../compareTypes';\n\nimport type Validation, {IdentifierPath} from '../Validation';\n\n// Any subtype of T\n\nexport default class $SubType<T> extends Type<$Subtype<T>> {\n  typeName: string = '$SubType';\n\n  type: Type<T>;\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    return this.type.collectErrors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    return this.type.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$Subtype<T>> {\n    return this.type;\n  }\n\n  toString (): string {\n    return `$Subtype<${this.type.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}","/* @flow */\n\nimport Type from '../types/Type';\nimport compareTypes from '../compareTypes';\n\nimport type Validation, {IdentifierPath} from '../Validation';\n\n// Any, but at least T.\n\nexport default class $SuperType<T> extends Type<$Supertype<T>> {\n  typeName: string = '$SuperType';\n\n  type: Type<T>;\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    return this.type.collectErrors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    return this.type.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$Supertype<T>> {\n    return this.type;\n  }\n\n  toString (): string {\n    return `$Supertype<${this.type.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}","/* @flow */\n\nimport Type from '../types/Type';\nimport TupleType from '../types/TupleType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport invariant from '../invariant';\n\nimport FunctionType from '../types/FunctionType';\n\n\nimport type Validation, {IdentifierPath} from '../Validation';\n\ntype Mapper = <V: any, R: any> (v: V) => R;\n\n// Map over the values in a tuple.\n\nexport default class $TupleMapType<T: [], M: Mapper> extends Type<$TupleMap<T, M>> {\n  typeName: string = '$TupleMapType';\n\n  tuple: Type<T>;\n  mapper: Type<M>;\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    let {tuple, mapper, context} = this;\n    const target = tuple.unwrap();\n    invariant(target instanceof TupleType, 'Target must be a tuple type.');\n\n    if (!context.checkPredicate('Array', input)) {\n      validation.addError(path, this, getErrorMessage('ERR_EXPECT_ARRAY'));\n      return true;\n    }\n\n    let hasErrors = false;\n    for (let i = 0; i < target.types.length; i++) {\n      const type = target.types[i];\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      const expected = applied.invoke(type);\n      const value = input[i];\n      if (expected.collectErrors(validation, path.concat(i), value)) {\n        hasErrors = true;\n      }\n    }\n\n    return hasErrors;\n  }\n\n  accepts (input: any): boolean {\n    let {tuple, mapper, context} = this;\n    const target = tuple.unwrap();\n    invariant(target instanceof TupleType, 'Target must be a tuple type.');\n\n    if (!context.checkPredicate('Array', input)) {\n      return false;\n    }\n\n    for (let i = 0; i < target.types.length; i++) {\n      const type = target.types[i];\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      if (!applied.invoke(type).accepts(input[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$TupleMap<T, M>> {\n    let {tuple, mapper, context} = this;\n    const target = tuple.unwrap();\n    invariant(target instanceof TupleType, 'Target must be an tuple type.');\n\n    const args = [];\n    for (let i = 0; i < target.types.length; i++) {\n      const type = target.types[i];\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      args.push(applied.invoke(type).unwrap().unwrap());\n    }\n\n    return context.tuple(...args);\n  }\n\n  toString (): string {\n    return `$TupleMap<${this.tuple.toString()}, ${this.mapper.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      tuple: this.tuple,\n      mapper: this.mapper\n    };\n  }\n}","/* @flow */\n\nimport Type from '../types/Type';\nimport GenericType from '../types/GenericType';\nimport TypeParameterApplication from '../types/TypeParameterApplication';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\n\nimport type Validation, {IdentifierPath} from '../Validation';\n\nexport default class ClassType<T> extends Type {\n  typeName: string = 'ClassType';\n\n  instanceType: Type<T>;\n\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any): boolean {\n    const {instanceType, context} = this;\n    if (typeof input !== 'function') {\n      validation.addError(path, this, getErrorMessage('ERR_EXPECT_CLASS', instanceType.toString()));\n      return true;\n    }\n    const expectedType = instanceType.unwrap();\n    if (expectedType instanceof GenericType && typeof expectedType.impl === 'function') {\n      if (input === expectedType.impl) {\n        return false;\n      }\n      else if (expectedType.impl.prototype.isPrototypeOf(input.prototype)) {\n        return false;\n      }\n      else {\n        validation.addError(path, this, getErrorMessage('ERR_EXPECT_CLASS', instanceType.toString()));\n        return true;\n      }\n    }\n    const annotation = context.getAnnotation(input);\n    if (annotation) {\n      return expectedType.acceptsType(annotation);\n    }\n    let matches;\n    // we're dealing with a type\n    switch (input.typeName) {\n      case 'NumberType':\n      case 'NumericLiteralType':\n        matches = input === Number;\n        break;\n      case 'BooleanType':\n      case 'BooleanLiteralType':\n        matches = input === Boolean;\n        break;\n      case 'StringType':\n      case 'StringLiteralType':\n        matches = input === String;\n        break;\n      case 'ArrayType':\n      case 'TupleType':\n        matches = input === Array;\n        break;\n      default:\n        return false;\n    }\n    if (matches) {\n      return false;\n    }\n    else {\n      validation.addError(path, this, getErrorMessage('ERR_EXPECT_CLASS', instanceType.toString()));\n      return true;\n    }\n  }\n\n  accepts (input: any): boolean {\n    const {instanceType, context} = this;\n    if (typeof input !== 'function') {\n        return false;\n      }\n      let expectedType = instanceType.unwrap();\n      if (expectedType instanceof GenericType && typeof expectedType.impl === 'function') {\n        if (input === expectedType.impl) {\n          return true;\n        }\n        else if (typeof expectedType.impl === 'function') {\n          if (expectedType.impl.prototype.isPrototypeOf(input.prototype)) {\n            return true;\n          }\n          else {\n            return false;\n          }\n        }\n      }\n\n      const annotation = context.getAnnotation(input);\n\n      if (annotation) {\n        return expectedType.acceptsType(annotation);\n      }\n      else if (expectedType instanceof TypeParameterApplication) {\n        expectedType = expectedType.parent;\n      }\n\n      if (expectedType instanceof GenericType && typeof expectedType.impl === 'function') {\n        if (expectedType.impl.prototype.isPrototypeOf(input.prototype)) {\n          return true;\n        }\n        else {\n          return false;\n        }\n      }\n\n      // we're dealing with a type\n      switch (input.typeName) {\n        case 'NumberType':\n        case 'NumericLiteralType':\n          return input === Number;\n        case 'BooleanType':\n        case 'BooleanLiteralType':\n          return input === Boolean;\n        case 'StringType':\n        case 'StringLiteralType':\n          return input === String;\n        case 'ArrayType':\n        case 'TupleType':\n          return input === Array;\n        default:\n          return false;\n      }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const {instanceType} = this;\n    if (input instanceof ClassType) {\n      return compareTypes(instanceType, input.instanceType);\n    }\n    return -1;\n  }\n\n  toString (): string {\n    return `Class<${this.instanceType.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      instanceType: this.instanceType\n    };\n  }\n}","/* @flow */\n\nimport TypeInferrer from './TypeInferrer';\nimport primitiveTypes from './primitiveTypes';\nimport invariant from './invariant';\n\nimport Validation from './Validation';\n\nimport makeReactPropTypes from './makeReactPropTypes';\n\nimport makeJSONError from './errorReporting/makeJSONError';\nimport makeTypeError from './errorReporting/makeTypeError';\nimport makeWarningMessage from './errorReporting/makeWarningMessage';\n\nimport makeUnion from './makeUnion';\nimport compareTypes from './compareTypes';\nimport {makePropertyDescriptor} from './classDecorators';\n\nimport {flowIntoTypeParameter} from './types/TypeParameter';\n\nimport annotateValue from './annotateValue';\n\nimport type {PropTypeDict} from './makeReactPropTypes';\nimport type {IdentifierPath} from './Validation';\n\n\nimport {\n  Type,\n  TypeParameter,\n  TypeBox,\n  TypeReference,\n  TypeTDZ,\n  ParameterizedTypeAlias,\n  TypeAlias,\n  TypeConstructor,\n  GenericType,\n  NullLiteralType,\n  NumberType,\n  NumericLiteralType,\n  BooleanType,\n  BooleanLiteralType,\n  SymbolType,\n  SymbolLiteralType,\n  StringType,\n  StringLiteralType,\n  ArrayType,\n  ObjectType,\n  ObjectTypeCallProperty,\n  ObjectTypeIndexer,\n  ObjectTypeProperty,\n  FlowIntoType,\n  FunctionType,\n  ParameterizedFunctionType,\n  FunctionTypeParam,\n  FunctionTypeRestParam,\n  FunctionTypeReturn,\n  GeneratorType,\n  ExistentialType,\n  AnyType,\n  MixedType,\n  EmptyType,\n  NullableType,\n  ThisType,\n  TupleType,\n  UnionType,\n  IntersectionType,\n  VoidType,\n  RefinementType\n} from './types';\n\nimport {\n  Declaration,\n  TypeDeclaration,\n  VarDeclaration,\n  ModuleDeclaration,\n  ModuleExportsDeclaration,\n  ClassDeclaration,\n  ParameterizedClassDeclaration,\n  ExtendsDeclaration\n} from './declarations';\n\nimport {\n  $DiffType,\n  $FlowFixMeType,\n  $KeysType,\n  $ObjMapiType,\n  $ObjMapType,\n  $PropertyType as _$PropertyType,\n  $ShapeType,\n  $SubType,\n  $SuperType,\n  $TupleMapType,\n  ClassType\n} from './flowTypes';\n\nimport {\n  ParentSymbol,\n  NameRegistrySymbol,\n  ModuleRegistrySymbol,\n  CurrentModuleSymbol,\n  TypeConstructorRegistrySymbol,\n  TypeParametersSymbol,\n  InferrerSymbol,\n  TypePredicateRegistrySymbol,\n  TypeSymbol\n} from './symbols';\n\nimport type {\n  TypeConstraint,\n  TypeCreator,\n  TypeRevealer,\n  FunctionBodyCreator,\n  ApplicableType,\n  ValidFunctionBody,\n  ObjectPropertyDict,\n  ValidObjectBody\n} from './types';\n\nimport type {\n  ClassBodyCreator,\n  ValidClassBody\n} from './declarations';\n\nexport type TypeConstructorConfig = {\n  name: string;\n  impl?: Function;\n  typeName: string;\n  collectErrors (validation: Validation<any>, path: IdentifierPath, input: any, instanceType: Type<any>): boolean;\n  accepts (input: any, ...typeInstances: Type<any>[]): boolean;\n  inferTypeParameters (input: any): Type<any>[];\n};\n\nexport type TypePredicate = (input: any) => boolean;\n\ntype NameRegistry = {\n  [name: string]: Type<any> | Class<TypeConstructor<any>>;\n};\n\ntype TypePredicateRegistry = {\n  [name: string]: TypePredicate;\n};\n\ntype ModuleRegistry = {\n  [name: string]: ModuleDeclaration;\n};\n\ntype TypeConstructorRegistry = Map<Function, Class<TypeConstructor<any>>>;\n\nexport type MatchClause<P, R> = (...params: P[]) => R;\nexport type PatternMatcher<P, R> = (...params: P[]) => R;\n\nexport type CheckMode\n  = 'assert'\n  | 'warn'\n  ;\n\n/**\n * Keeps track of invalid references in order to prevent\n * multiple warnings.\n */\nconst warnedInvalidReferences: WeakSet<any> = new WeakSet();\n\nexport default class TypeContext {\n\n  /**\n   * Calls to `t.check(...)` will call either\n   * `t.assert(...)` or `t.warn(...)` depending on this setting.\n   */\n  mode: CheckMode = 'assert';\n\n  // @flowIssue 252\n  [ParentSymbol]: ? TypeContext;\n\n  // @flowIssue 252\n  [NameRegistrySymbol]: NameRegistry = {};\n\n  // @flowIssue 252\n  [TypePredicateRegistrySymbol]: TypePredicateRegistry = {};\n\n  // @flowIssue 252\n  [TypeConstructorRegistrySymbol]: TypeConstructorRegistry = new Map();\n\n  // @flowIssue 252\n  [InferrerSymbol]: TypeInferrer = new TypeInferrer(this);\n\n  // @flowIssue 252\n  [ModuleRegistrySymbol]: ModuleRegistry = {};\n\n  // @flowIssue 252\n  [CurrentModuleSymbol]: ? ModuleDeclaration;\n\n\n  makeJSONError <T> (validation: Validation<T>): ? Array<Object> {\n    return makeJSONError(validation);\n  }\n\n  makeTypeError <T> (validation: Validation<T>): ? TypeError {\n    return makeTypeError(validation);\n  }\n\n  createContext (): TypeContext {\n    const context = new TypeContext();\n    // @flowIssue 252\n    context[ParentSymbol] = this;\n    return context;\n  }\n\n  typeOf <T> (input: T): Type<T> {\n\n    const annotation = this.getAnnotation(input);\n    if (annotation) {\n      return annotation;\n    }\n    // @flowIssue 252\n    const inferrer = this[InferrerSymbol];\n    (inferrer: TypeInferrer);\n\n    return inferrer.infer(input);\n  }\n\n  compareTypes (a: Type<any>, b: Type<any>): -1 | 0 | 1 {\n    return compareTypes(a, b);\n  }\n\n  get (name: string): ? Type<any> {\n    // @flowIssue 252\n    const item = this[NameRegistrySymbol][name];\n    if (item != null) {\n      if (typeof item === 'function') {\n        return new item(this);\n      }\n      else {\n        return item;\n      }\n    }\n    // @flowIssue 252\n    const parent = this[ParentSymbol];\n    if (parent) {\n      return parent.get(name);\n    }\n  }\n\n  /**\n   * Get the predicate for a given type name.\n   * e.g. `t.getPredicate('Array')`.\n   */\n  getPredicate (name: string): ? TypePredicate {\n    const item: ? TypePredicate = (this: any)[TypePredicateRegistrySymbol][name];\n    if (item) {\n      return item;\n    }\n    const parent: ? TypeContext = (this: any)[ParentSymbol];\n    if (parent) {\n      return parent.getPredicate(name);\n    }\n  }\n\n  /**\n   * Set the predicate for a given type name.\n   * This can be used to customise the behaviour of things like Array\n   * detection or allowing Thenables in place of the global Promise.\n   */\n  setPredicate (name: string, predicate: TypePredicate) {\n    (this: any)[TypePredicateRegistrySymbol][name] = predicate;\n  }\n\n  /**\n   * Check the given value against the named predicate.\n   * Returns false if no such predicate exists.\n   * e.g. `t.checkPredicate('Array', [1, 2, 3])`\n   */\n  checkPredicate (name: string, input: any): boolean {\n    const predicate = this.getPredicate(name);\n    if (predicate) {\n      return predicate(input);\n    }\n    else {\n      return false;\n    }\n  }\n\n  /**\n   * Returns a decorator for a function or object with the given type.\n   */\n  decorate (type: (() => Type<any>) | Type<any>, shouldAssert?: boolean): * {\n    if (shouldAssert == null) {\n      shouldAssert = this.mode === 'assert';\n    }\n    return (input: Object | Function, propertyName?: string, descriptor?: Object): * => {\n      if (descriptor && typeof propertyName === 'string') {\n        return makePropertyDescriptor(type, input, propertyName, descriptor, Boolean(shouldAssert));\n      }\n      else {\n        invariant(typeof type !== 'function', 'Cannot decorate an object or function as a method.');\n        return this.annotate(input, type);\n      }\n    };\n  }\n\n  /**\n   * Annotates an object or function with the given type.\n   * If a type is specified as the sole argument, returns a\n   * function which can decorate classes or functions with the given type.\n   */\n  annotate <T> (input: Type<T> | T, type?: Type<T>) {\n    if (type === undefined) {\n      return annotateValue(input);\n    }\n    else {\n      return annotateValue(input, type);\n    }\n  }\n\n  getAnnotation <T> (input: T): ? Type<T> {\n    if ((input !== null && typeof input === 'object') || typeof input === 'function') {\n      // @flowIssue 252\n      return input[TypeSymbol];\n    }\n  }\n\n  hasAnnotation (input: any): boolean {\n    if (input == null) {\n      return false;\n    }\n    else {\n      return input[TypeSymbol] ? true : false;\n    }\n  }\n\n  setAnnotation <T: Object | Function> (input: T, type: Type<T>): T {\n    input[TypeSymbol] = type;\n    return input;\n  }\n\n  type <T> (name: string, type: Type<T> | TypeCreator<Type<T>>): TypeAlias<T> | ParameterizedTypeAlias<T> {\n    if (typeof type === 'function') {\n      const target = new ParameterizedTypeAlias(this);\n      target.name = name;\n      target.typeCreator = type;\n      return target;\n    }\n    else {\n      const target = new TypeAlias(this);\n      target.name = name;\n      target.type = type;\n      return target;\n    }\n  }\n\n  declare <T: any, D: ModuleDeclaration | TypeDeclaration<T> | VarDeclaration<T> | ClassDeclaration<T>> (name: string | D, type?: Type<T> | TypeCreator<Type<T>>): D | TypeDeclaration<T> {\n\n    if (name instanceof Declaration) {\n      type = name;\n      name = type.name;\n    }\n    else if (name instanceof TypeAlias) {\n      type = name;\n      name = type.name;\n    }\n    if (typeof type === 'function') {\n      type = this.type(name, type);\n    }\n    if (type instanceof ModuleDeclaration) {\n      const moduleRegistry: ModuleRegistry = (this: $FlowIssue<252>)[ModuleRegistrySymbol];\n      moduleRegistry[name] = type;\n      return type;\n    }\n    else {\n      invariant(typeof name === 'string', 'Name must be a string');\n      invariant(type instanceof Type, 'Type must be supplied to declaration');\n      const nameRegistry: NameRegistry = (this: $FlowIssue<252>)[NameRegistrySymbol];\n\n      if (type instanceof Declaration) {\n        nameRegistry[name] = type;\n        return type;\n      }\n      else if (type instanceof TypeAlias || type instanceof ParameterizedTypeAlias) {\n        const target = new TypeDeclaration(this);\n        target.name = name;\n        target.typeAlias = type;\n        nameRegistry[name] = target;\n        return target;\n      }\n      else {\n        const target = this.var(name, type);\n        nameRegistry[name] = target;\n        return target;\n      }\n    }\n  }\n\n  *declarations (): Generator<[string, Type<any> | TypeConstructor<any>], void, void> {\n    const nameRegistry: NameRegistry = (this: $FlowIssue<252>)[NameRegistrySymbol];\n    for (const key in nameRegistry) { // eslint-disable-line guard-for-in\n      yield [key, nameRegistry[key]];\n    }\n  }\n\n  *modules (): Generator<ModuleDeclaration, void, void> {\n    const moduleRegistry: ModuleRegistry = (this: $FlowIssue<252>)[ModuleRegistrySymbol];\n    for (const key in moduleRegistry) { // eslint-disable-line guard-for-in\n      yield moduleRegistry[key];\n    }\n  }\n\n  import (moduleName: string): ? ModuleDeclaration {\n    const moduleRegistry: ModuleRegistry = (this: $FlowIssue<252>)[ModuleRegistrySymbol];\n    if (moduleRegistry[moduleName]) {\n      return moduleRegistry[moduleName];\n    }\n    const [head] = moduleName.split('/');\n    const module = moduleRegistry[head];\n    if (module) {\n      return module.import(moduleName);\n    }\n    const parent = (this: $FlowIssue<252>)[ParentSymbol];\n    if (parent) {\n      return parent.import(moduleName);\n    }\n  }\n\n  declareTypeConstructor ({name, impl, typeName, collectErrors, accepts, inferTypeParameters}: TypeConstructorConfig): TypeConstructor<any> {\n    const nameRegistry: NameRegistry = (this: $FlowIssue<252>)[NameRegistrySymbol];\n\n    if (nameRegistry[name]) {\n      throw new Error(`Cannot redeclare type: ${name}`);\n    }\n\n    const target = new TypeConstructor(this);\n    target.name = name;\n    target.typeName = typeName;\n    target.impl = impl;\n    target.collectErrors = collectErrors;\n    target.accepts = accepts;\n    target.inferTypeParameters = inferTypeParameters;\n\n    nameRegistry[name] = target;\n\n    if (typeof impl === 'function') {\n      // @flowIssue 252\n      const handlerRegistry = this[TypeConstructorRegistrySymbol];\n      (handlerRegistry: TypeConstructorRegistry);\n\n      if (handlerRegistry.has(impl)) {\n        throw new Error(`A type handler already exists for the given implementation.`);\n      }\n      handlerRegistry.set(impl, target);\n    }\n    return target;\n  }\n\n  getTypeConstructor (impl: Function): ? TypeConstructor<any> {\n    // @flowIssue 252\n    const handlerRegistry = this[TypeConstructorRegistrySymbol];\n    (handlerRegistry: TypeConstructorRegistry);\n\n    return handlerRegistry.get(impl);\n  }\n\n  literal <T: void | null | boolean | number | string | Symbol> (input: T): Type<T> {\n    if (input === undefined) {\n      return this.void();\n    }\n    else if (input === null) {\n      return this.null();\n    }\n    else if (typeof input === 'boolean') {\n      return this.boolean(input);\n    }\n    else if (typeof input === 'number') {\n      return this.number(input);\n    }\n    else if (typeof input === 'string') {\n      return this.string(input);\n    }\n    // @flowIssue 252\n    else if (typeof input === 'symbol') {\n      return this.symbol(input);\n    }\n    else {\n      return this.typeOf(input);\n    }\n  }\n\n  null (): NullLiteralType {\n    return primitiveTypes.null;\n  }\n\n  nullable <T> (type: Type<T>): NullableType<T> {\n    const target = new NullableType(this);\n    target.type = type;\n    return target;\n  }\n\n  existential (): ExistentialType {\n    return primitiveTypes.existential;\n  }\n\n\n  empty (): EmptyType {\n    return primitiveTypes.empty;\n  }\n\n  any (): AnyType {\n    return primitiveTypes.any;\n  }\n\n  mixed (): MixedType {\n    return primitiveTypes.mixed;\n  }\n\n  void (): VoidType {\n    return primitiveTypes.void;\n  }\n\n  this <T> (input?: T): ThisType<T> {\n    const target = new ThisType(this);\n    if (input !== undefined) {\n      target.recorded = input;\n    }\n    return target;\n  }\n\n  number <T: number> (input?: T): NumberType | NumericLiteralType<T> {\n    if (input !== undefined) {\n      const target = new NumericLiteralType(this);\n      target.value = input;\n      return target;\n    }\n    else {\n      return primitiveTypes.number;\n    }\n  }\n\n  boolean <T: boolean> (input?: T): BooleanType | BooleanLiteralType<T> {\n    if (input !== undefined) {\n      const target = new BooleanLiteralType(this);\n      target.value = input;\n      return target;\n    }\n    else {\n      return primitiveTypes.boolean;\n    }\n  }\n\n  string <T: string> (input?: T): StringType | StringLiteralType<T> {\n    if (input !== undefined) {\n      const target = new StringLiteralType(this);\n      target.value = input;\n      return target;\n    }\n    else {\n      return primitiveTypes.string;\n    }\n  }\n\n  symbol <T: Symbol> (input?: T): SymbolType | SymbolLiteralType<T> {\n    if (input !== undefined) {\n      const target = new SymbolLiteralType(this);\n      target.value = input;\n      return target;\n    }\n    else {\n      return primitiveTypes.symbol;\n    }\n  }\n\n  typeParameter <T> (id: string, bound?: Type<T>, defaultType?: Type<T>): TypeParameter<T> {\n    const target = new TypeParameter(this);\n    target.id = id;\n    target.bound = bound;\n    target.default = defaultType;\n    return target;\n  }\n\n  flowInto <T> (typeParameter: TypeParameter<T>): FlowIntoType<T> {\n    return flowIntoTypeParameter(typeParameter);\n  }\n\n  /**\n   * Bind the type parameters for the parent class of the given instance.\n   */\n  bindTypeParameters <T: {}> (subject: T, ...typeInstances: Type<any>[]): T {\n\n    const instancePrototype = Object.getPrototypeOf(subject);\n    // @flowIssue\n    const parentPrototype = instancePrototype && Object.getPrototypeOf(instancePrototype);\n    // @flowIssue\n    const parentClass = parentPrototype && parentPrototype.constructor;\n\n    if (!parentClass) {\n      this.emitWarningMessage('Could not bind type parameters for non-existent parent class.');\n      return subject;\n    }\n    // @flowIssue 252\n    const typeParametersPointer = parentClass[TypeParametersSymbol];\n\n    if (typeParametersPointer) {\n      const typeParameters = subject[typeParametersPointer];\n      const keys = Object.keys(typeParameters);\n      const length = Math.min(keys.length, typeInstances.length);\n      for (let i = 0; i < length; i++) {\n        const typeParam = typeParameters[keys[i]];\n        typeParam.bound = typeInstances[i];\n      }\n    }\n    return subject;\n  }\n\n  module (name: string, body: (context: TypeContext) => any): ModuleDeclaration {\n    const target = new ModuleDeclaration(this);\n    target.name = name;\n    const innerContext = this.createContext();\n    // @flowIssue 252\n    innerContext[ParentSymbol] = this;\n    // @flowIssue 252\n    innerContext[CurrentModuleSymbol] = target;\n\n    target.innerContext = innerContext;\n    body(innerContext);\n    return target;\n  }\n\n  moduleExports <T> (type: Type<T>): ModuleExportsDeclaration<T> {\n    const currentModule: ModuleDeclaration = (this: $FlowIssue<252>)[CurrentModuleSymbol];\n    if (!currentModule) {\n      throw new Error('Cannot declare module.exports outside of a module.');\n    }\n    const target = new ModuleExportsDeclaration(this);\n    target.type = type;\n    currentModule.moduleExports = target;\n    return target;\n  }\n\n  var <T> (name: string, type: Type<T>): VarDeclaration<T> {\n    const target = new VarDeclaration(this);\n    target.name = name;\n    target.type = type;\n    return target;\n  }\n\n  class <X, O: Object> (name: string, head: ClassBodyCreator<X, O> | ValidClassBody<X, O>, ...tail: Array<ValidClassBody<X, O>>): ClassDeclaration<O> {\n    if (typeof head === 'function') {\n      const target = new ParameterizedClassDeclaration(this);\n      target.name = name;\n      target.bodyCreator = head;\n      return target;\n    }\n    const target = new ClassDeclaration(this);\n    target.name = name;\n    tail.unshift(head);\n    const {length} = tail;\n    const properties = [];\n    let body;\n\n    for (let i = 0; i < length; i++) {\n      const item = tail[i];\n      if (item instanceof ObjectTypeProperty) {\n        properties.push(item);\n      }\n      else if (item instanceof ObjectType) {\n        invariant(!body, 'Class body must only be declared once.');\n        body = item;\n      }\n      else if (item instanceof ExtendsDeclaration) {\n        invariant(!target.superClass, 'Classes can only have one super class.');\n        target.superClass = item;\n      }\n      else if (item != null && typeof item === 'object' && !(item instanceof Type)) {\n        for (const propertyName in item) { // eslint-disable-line\n          properties.push(this.property(propertyName, item[propertyName]));\n        }\n      }\n      else {\n        throw new Error('ClassDeclaration cannot contain the given type directly.');\n      }\n    }\n    if (!body) {\n      body = new ObjectType(this);\n    }\n    if (properties.length) {\n      body.properties.push(...properties);\n    }\n    target.body = body;\n    return target;\n  }\n\n  extends <T, P> (subject: string | ApplicableType<T> | Function, ...typeInstances: Type<P>[]): ExtendsDeclaration<T> {\n    const target = new ExtendsDeclaration(this);\n    target.type = this.ref(subject, ...typeInstances);\n    return target;\n  }\n\n  fn <X, P, R> (head: FunctionBodyCreator<X, P, R> | ValidFunctionBody<X, P, R>, ...tail: Array<ValidFunctionBody<X, P, R>>): ParameterizedFunctionType<X, P, R> | FunctionType<P, R> {\n    return this.function(head, ...tail);\n  }\n\n  function <X, P, R> (head: ? FunctionBodyCreator<X, P, R> | ValidFunctionBody<X, P, R>, ...tail: Array<ValidFunctionBody<X, P, R>>): ParameterizedFunctionType<X, P, R> | FunctionType<P, R> {\n    if (typeof head === 'function') {\n      const target = new ParameterizedFunctionType(this);\n      target.bodyCreator = head;\n      return target;\n    }\n    const target = new FunctionType(this);\n    if (head != null) {\n      tail.unshift(head);\n      const {length} = tail;\n      for (let i = 0; i < length; i++) {\n        const item = tail[i];\n        if (item instanceof FunctionTypeParam) {\n          target.params.push(item);\n        }\n        else if (item instanceof FunctionTypeRestParam) {\n          target.rest = item;\n        }\n        else if (item instanceof FunctionTypeReturn) {\n          target.returnType = item;\n        }\n        else {\n          throw new Error('FunctionType cannot contain the given type directly.');\n        }\n      }\n    }\n    if (!target.returnType) {\n      target.returnType = this.any();\n    }\n    return target;\n  }\n\n  param <T> (name: string, type: Type<T>, optional: boolean = false): FunctionTypeParam<T> {\n    const target = new FunctionTypeParam(this);\n    target.name = name;\n    target.type = type;\n    target.optional = optional;\n    return target;\n  }\n\n  rest <T> (name: string, type: Type<T>): FunctionTypeRestParam<T> {\n    const target = new FunctionTypeRestParam(this);\n    target.name = name;\n    target.type = type;\n    return target;\n  }\n\n  return <T> (type: Type<T>): FunctionTypeReturn<T> {\n    const target =  new FunctionTypeReturn(this);\n    target.type = type;\n    return target;\n  }\n\n  generator <Y, R, N> (yieldType: Type<Y>, returnType?: Type<R>, nextType?: Type<N>): GeneratorType<Y, R, N> {\n    const target = new GeneratorType(this);\n    target.yieldType = yieldType;\n    target.returnType = returnType || this.any();\n    target.nextType = nextType || this.any();\n    return target;\n  }\n\n  object <T: {}> (head: ? ValidObjectBody<T> | $ObjMap<T, <V>(v: V) => Type<V>>, ...tail: ValidObjectBody<T>[]): ObjectType<T> {\n    const target = new ObjectType(this);\n    if (head != null && typeof head === 'object' && !(head instanceof Type)) {\n      for (const propertyName in head) { // eslint-disable-line\n        target.properties.push(this.property(propertyName, head[propertyName]));\n      }\n    }\n    else {\n      let body;\n      if (head) {\n        body = [head, ...tail];\n      }\n      else {\n        body = tail;\n      }\n      const {length} = body;\n      for (let i = 0; i < length; i++) {\n        const item = body[i];\n        if (item instanceof ObjectTypeProperty) {\n          target.properties.push(item);\n        }\n        else if (item instanceof ObjectTypeIndexer) {\n          target.indexers.push(item);\n        }\n        else if (item instanceof ObjectTypeCallProperty) {\n          target.callProperties.push(item);\n        }\n        else {\n          throw new Error('ObjectType cannot contain the given type directly.');\n        }\n      }\n    }\n    return target;\n  }\n\n  exactObject <T: {}> (head: ? ValidObjectBody<T> | $ObjMap<T, <V>(v: V) => Type<V>>, ...tail: ValidObjectBody<T>[]): ObjectType<T> {\n    const object = this.object(head, ...tail);\n    object.exact = true;\n    return object;\n  }\n\n  callProperty <T> (value: Type<T>): ObjectTypeCallProperty<T> {\n    const target = new ObjectTypeCallProperty(this);\n    target.value = value;\n    return target;\n  }\n\n  property <K: string | number, V> (key: K, value: Type<V> | ObjectPropertyDict<Object>, optional: boolean = false): ObjectTypeProperty<K, V> {\n    const target = new ObjectTypeProperty(this);\n    target.key = key;\n    if (value instanceof Type) {\n      target.value = value;\n    }\n    else {\n      target.value = this.object(value);\n    }\n    target.optional = optional;\n    return target;\n  }\n\n  indexer <K, V> (id: string, key: Type<K>, value: Type<V>): ObjectTypeIndexer<K, V> {\n    const target = new ObjectTypeIndexer(this);\n    target.id = id;\n    target.key = key;\n    target.value = value;\n    return target;\n  }\n\n  method <K: string | number, X, P, R> (name: K, head: FunctionBodyCreator<X, P, R> | ValidFunctionBody<X, P, R>, ...tail: Array<ValidFunctionBody<X, P, R>>): ObjectTypeProperty<K, (...params: P[]) => R> {\n    const target = new ObjectTypeProperty(this);\n    target.key = name;\n    target.value = this.function(head, ...tail);\n    return target;\n  }\n\n  staticProperty <K: string | number, V> (key: K, value: Type<V> | ObjectPropertyDict<Object>, optional: boolean = false): ObjectTypeProperty<K, V> {\n    const prop = this.property(key, value, optional);\n    (prop: $FlowIssue).static = true;\n    return prop;\n  }\n\n  staticMethod <K: string | number, X, P, R> (name: K, head: FunctionBodyCreator<X, P, R> | ValidFunctionBody<X, P, R>, ...tail: Array<ValidFunctionBody<X, P, R>>): ObjectTypeProperty<K, (...params: P[]) => R> {\n    const prop = this.method(name, head, ...tail);\n    (prop: $FlowIssue).static = true;\n    return prop;\n  }\n\n  tuple <T> (...types: Type<T>[]): TupleType<any> {\n    const target = new TupleType(this);\n    target.types = types;\n    return target;\n  }\n\n  array <T> (elementType?: Type<T>): ArrayType<T> {\n    const target = new ArrayType(this);\n    target.elementType = elementType || this.any();\n    return target;\n  }\n\n  union <T> (...types: Type<T>[]): UnionType<T> {\n    return makeUnion(this, types);\n  }\n\n  intersect <T: {}> (...types: Type<T>[]): IntersectionType<T> {\n    const target = new IntersectionType(this);\n    target.types = types;\n    return target;\n  }\n\n  intersection <T: {}> (...types: Type<T>[]): IntersectionType<T> {\n    return this.intersect(...types);\n  }\n\n  box <T> (reveal: TypeRevealer<T>): TypeBox<T> {\n    const box = new TypeBox(this);\n    box.reveal = reveal;\n    return box;\n  }\n\n  tdz <T> (reveal: TypeRevealer<T>): TypeTDZ<T> {\n    const tdz = new TypeTDZ(this);\n    tdz.reveal = reveal;\n    return tdz;\n  }\n\n  ref <T, P> (subject: string | ApplicableType<T> | Function, ...typeInstances: Type<P>[]): Type<T | any> {\n    let target;\n    if (typeof subject === 'string') {\n      // try and eagerly resolve the reference\n      target = this.get(subject);\n      if (!target) {\n        // defer dereferencing for now\n        target = new TypeReference(this);\n        target.name = subject;\n      }\n    }\n    else if (typeof subject === 'function') {\n      // @flowIssue 252\n      const handlerRegistry = this[TypeConstructorRegistrySymbol];\n      (handlerRegistry: TypeConstructorRegistry);\n\n      // see if we have a dedicated TypeConstructor for this.\n      target = handlerRegistry.get(subject);\n\n      if (!target) {\n        // just use a generic type handler.\n        target = new GenericType(this);\n        target.impl = subject;\n        target.name = subject.name;\n      }\n\n    }\n    else if (subject instanceof Type) {\n      target = subject;\n    }\n    else {\n      if (subject == null || typeof subject !== 'object') {\n        this.emitWarningMessage(`Could not reference the given type, try t.typeOf(value) instead. (got ${String(subject)})`);\n      }\n      else if (!warnedInvalidReferences.has(subject)) {\n        this.emitWarningMessage('Could not reference the given type, try t.typeOf(value) instead.');\n        warnedInvalidReferences.add(subject);\n      }\n      return this.any();\n    }\n\n    if (typeInstances.length) {\n      invariant(typeof target.apply === 'function', `Cannot apply non-applicable type: ${target.typeName}.`);\n      return target.apply(...typeInstances);\n    }\n    else {\n      return target;\n    }\n  }\n\n  validate <T> (type: Type<T>, input: any, prefix: string = '', path?: string[]): Validation<T> {\n    const validation = new Validation(this, input);\n    if (path) {\n      validation.path.push(...path);\n    }\n    else if (typeof type.name === 'string') {\n      validation.path.push(type.name);\n    }\n    validation.prefix = prefix;\n    type.collectErrors(validation, [], input);\n    return validation;\n  }\n\n  check <T, V: T | any> (type: Type<T>, input: V, prefix: string = '', path?: string[]): V {\n    if (this.mode === 'assert') {\n      return this.assert(type, input, prefix, path);\n    }\n    else {\n      return this.warn(type, input, prefix, path);\n    }\n  }\n\n  assert <T, V: T | any> (type: Type<T>, input: V, prefix: string = '', path?: string[]): V {\n    const validation = this.validate(type, input, prefix, path);\n    const error = this.makeTypeError(validation);\n    if (error) {\n      throw error;\n    }\n    return input;\n  }\n\n  warn <T, V: T | any> (type: Type<T>, input: V, prefix: string = '', path?: string[]): V {\n    const validation = this.validate(type, input, prefix, path);\n    const message = makeWarningMessage(validation);\n    if (typeof message === 'string') {\n      this.emitWarningMessage(message);\n    }\n    return input;\n  }\n\n  /**\n   * Emits a warning message, using `console.warn()` by default.\n   */\n  emitWarningMessage (message: string): void {\n    console.warn('flow-runtime:', message);\n  }\n\n  propTypes <T: {}> (type: Type<T>): PropTypeDict<T> {\n    return makeReactPropTypes((type.unwrap(): $FlowIgnore));\n  }\n\n  match <P, R> (...args: Array<P | MatchClause<P, R>>): R {\n    const clauses: any = args.pop();\n    if (!Array.isArray(clauses)) {\n      throw new Error('Invalid pattern, last argument must be an array.');\n    }\n    (clauses: MatchClause<P, R>[]);\n    const pattern = this.pattern(...clauses);\n    return pattern(...args);\n  }\n\n  pattern <P, R> (...clauses: MatchClause<P, R>[]): PatternMatcher<P, R> {\n    const {length} = clauses;\n    const tests: Array<true | FunctionType<P, R> | ParameterizedFunctionType<any, P, R>> = new Array(length);\n    for (let i = 0; i < length; i++) {\n      const clause = clauses[i];\n      const annotation = this.getAnnotation(clause);\n      if (!annotation) {\n        if (i !== length - 1) {\n          throw new Error(`Invalid Pattern - found unannotated function in position ${i}, default clauses must be last.`);\n        }\n        tests[i] = true;\n      }\n      else {\n        invariant(annotation instanceof FunctionType || annotation instanceof ParameterizedFunctionType, 'Pattern clauses must be annotated functions.');\n        tests[i] = annotation;\n      }\n    }\n    return (...args: P[]): R => {\n      for (let i = 0; i < tests.length; i++) {\n        const test = tests[i];\n        const clause = clauses[i];\n        if (test === true) {\n          return clause(...args);\n        }\n        else if (test.acceptsParams(...args)) {\n          return clause(...args);\n        }\n      }\n      const error = new TypeError('Value did not match any of the candidates.');\n      error.name = 'RuntimeTypeError';\n      throw error;\n    };\n  }\n\n  wrapIterator <T> (type: Type<T>): (input: Iterable<T>) => Generator<T, void, void> {\n    const t = this;\n    return function* wrappedIterator (input: Iterable<T>): Generator<T, void, void> {\n      for (const item of input) {\n        yield t.check(type, item);\n      }\n    };\n  }\n\n  refinement <T> (type: Type<T>, ...constraints: TypeConstraint[]): RefinementType<T> {\n    const target = new RefinementType(this);\n    target.type = type;\n    target.addConstraint(...constraints);\n    return target;\n  }\n\n\n  $diff <A: {}, B: {}> (aType: Type<A>, bType: Type<B>): $DiffType<A, B> {\n    const target = new $DiffType(this);\n    target.aType = aType;\n    target.bType = bType;\n    return target;\n  }\n\n  $flowFixMe (): $FlowFixMeType {\n    return new $FlowFixMeType(this);\n  }\n\n  $keys <T: {}> (type: Type<T>): $KeysType<T> {\n    const target = new $KeysType(this);\n    target.type = type;\n    return target;\n  }\n\n  $objMap <O: {}, K: $Keys<O>, M: (k: K) => any> (object: Type<O>, mapper: Type<M>): $ObjMapType<O, M> {\n    const target = new $ObjMapType(this);\n    target.object = object;\n    target.mapper = mapper;\n    return target;\n  }\n\n  $objMapi <O: {}, K: $Keys<O>, M: (k: K, v: any) => any> (object: Type<O>, mapper: Type<M>): $ObjMapiType<O, M> {\n    const target = new $ObjMapiType(this);\n    target.object = object;\n    target.mapper = mapper;\n    return target;\n  }\n\n  $propertyType <O: {}, P: string | number | Symbol> (object: Type<O>, property: P | Type<P>): _$PropertyType<O, P> {\n    const target = new _$PropertyType(this);\n    target.object = object;\n    if (property instanceof Type) {\n      const unwrapped = property.unwrap();\n      target.property = (unwrapped: any).value;\n    }\n    else {\n      target.property = property;\n    }\n    return target;\n  }\n\n  $shape <T: {}> (type: Type<T>): $ShapeType<T> {\n    const target = new $ShapeType(this);\n    target.type = type;\n    return target;\n  }\n\n  $subtype <T: {}> (type: Type<T>): $SubType<T> {\n    const target = new $SubType(this);\n    target.type = type;\n    return target;\n  }\n\n  $supertype <T: {}> (type: Type<T>): $SuperType<T> {\n    const target = new $SuperType(this);\n    target.type = type;\n    return target;\n  }\n\n  $tupleMap <T: [], M: (v: *) => *> (tuple: Type<T>, mapper: Type<M>): $TupleMapType<T, M> {\n    const target = new $TupleMapType(this);\n    target.tuple = tuple;\n    target.mapper = mapper;\n    return target;\n  }\n\n  Class <T: {}> (instanceType: Type<T>): ClassType<T> {\n    const target = new ClassType(this);\n    target.instanceType = instanceType;\n    return target;\n  }\n}\n\n","/* @flow */\n\nimport registerPrimitiveTypes from './registerPrimitiveTypes';\nimport registerBuiltinTypeConstructors from './registerBuiltins';\nimport registerTypePredicates from './registerTypePredicates';\n\nimport TypeContext from './TypeContext';\n\nconst globalContext = new TypeContext();\nregisterPrimitiveTypes(globalContext);\nregisterBuiltinTypeConstructors(globalContext);\nregisterTypePredicates(globalContext);\n\n\nexport default globalContext;","/* @flow */\n\nimport globalContext from './globalContext';\n\nimport {\n  Type,\n  TypeParameter,\n  TypeBox,\n  TypeReference,\n  TypeTDZ,\n  ParameterizedTypeAlias,\n  TypeAlias,\n  TypeConstructor,\n  GenericType,\n  NullLiteralType,\n  NumberType,\n  NumericLiteralType,\n  BooleanType,\n  BooleanLiteralType,\n  SymbolType,\n  SymbolLiteralType,\n  StringType,\n  StringLiteralType,\n  ArrayType,\n  ObjectType,\n  ObjectTypeCallProperty,\n  ObjectTypeIndexer,\n  ObjectTypeProperty,\n  FlowIntoType,\n  FunctionType,\n  ParameterizedFunctionType,\n  PartialType,\n  FunctionTypeParam,\n  FunctionTypeRestParam,\n  FunctionTypeReturn,\n  GeneratorType,\n  ExistentialType,\n  AnyType,\n  MixedType,\n  EmptyType,\n  NullableType,\n  ThisType,\n  TupleType,\n  UnionType,\n  IntersectionType,\n  VoidType,\n  RefinementType,\n  TypeParameterApplication\n} from './types';\n\n\nimport {\n  Declaration,\n  TypeDeclaration,\n  VarDeclaration,\n  ModuleDeclaration,\n  ModuleExportsDeclaration,\n  ClassDeclaration,\n  ParameterizedClassDeclaration,\n  ExtendsDeclaration\n} from './declarations';\n\nimport {\n  TypeParametersSymbol\n} from './symbols';\n\nimport TypeContext from './TypeContext';\n\nfunction defineProperty (name: string, value: any) {\n  Object.defineProperty(globalContext, name, {\n    value: value\n  });\n}\n\ndefineProperty('TypeParametersSymbol', TypeParametersSymbol);\ndefineProperty('TypeContext', TypeContext);\ndefineProperty('Type', Type);\ndefineProperty('TypeBox', TypeBox);\ndefineProperty('TypeParameter', TypeParameter);\ndefineProperty('TypeReference', TypeReference);\ndefineProperty('TypeTDZ', TypeTDZ);\ndefineProperty('ParameterizedTypeAlias', ParameterizedTypeAlias);\ndefineProperty('TypeAlias', TypeAlias);\ndefineProperty('TypeConstructor', TypeConstructor);\ndefineProperty('GenericType', GenericType);\ndefineProperty('NullLiteralType', NullLiteralType);\ndefineProperty('NumberType', NumberType);\ndefineProperty('NumericLiteralType', NumericLiteralType);\ndefineProperty('BooleanType', BooleanType);\ndefineProperty('BooleanLiteralType', BooleanLiteralType);\ndefineProperty('SymbolType', SymbolType);\ndefineProperty('SymbolLiteralType', SymbolLiteralType);\ndefineProperty('StringType', StringType);\ndefineProperty('StringLiteralType', StringLiteralType);\ndefineProperty('ArrayType', ArrayType);\ndefineProperty('ObjectType', ObjectType);\ndefineProperty('ObjectTypeCallProperty', ObjectTypeCallProperty);\ndefineProperty('ObjectTypeIndexer', ObjectTypeIndexer);\ndefineProperty('ObjectTypeProperty', ObjectTypeProperty);\ndefineProperty('FunctionType', FunctionType);\ndefineProperty('FunctionTypeParam', FunctionTypeParam);\ndefineProperty('FunctionTypeRestParam', FunctionTypeRestParam);\ndefineProperty('FunctionTypeReturn', FunctionTypeReturn);\ndefineProperty('ParameterizedFunctionType', ParameterizedFunctionType);\ndefineProperty('PartialType', PartialType);\ndefineProperty('RefinementType', RefinementType);\ndefineProperty('TypeParameterApplication', TypeParameterApplication);\ndefineProperty('GeneratorType', GeneratorType);\ndefineProperty('ExistentialType', ExistentialType);\ndefineProperty('FlowIntoType', FlowIntoType);\ndefineProperty('AnyType', AnyType);\ndefineProperty('MixedType', MixedType);\ndefineProperty('EmptyType', EmptyType);\ndefineProperty('NullableType', NullableType);\ndefineProperty('ThisType', ThisType);\ndefineProperty('TupleType', TupleType);\ndefineProperty('UnionType', UnionType);\ndefineProperty('IntersectionType', IntersectionType);\ndefineProperty('VoidType', VoidType);\ndefineProperty('Declaration', Declaration);\ndefineProperty('VarDeclaration', VarDeclaration);\ndefineProperty('TypeDeclaration', TypeDeclaration);\ndefineProperty('ModuleDeclaration', ModuleDeclaration);\ndefineProperty('ModuleExportsDeclaration', ModuleExportsDeclaration);\ndefineProperty('ClassDeclaration', ClassDeclaration);\ndefineProperty('ParameterizedClassDeclaration', ParameterizedClassDeclaration);\ndefineProperty('ExtendsDeclaration', ExtendsDeclaration);\n\nexport default globalContext;\n"],"names":["primitiveTypes","makeJSONError","validation","hasErrors","input","context","errors","path","message","expectedType","expected","toString","actual","typeOf","resolvePath","field","stringifyPath","concat","pointer","join","push","validIdentifierOrAccessor","Validation","prefix","candidate","matchPath","length","didClear","error","parts","Array","i","part","test","String","subject","undefined","Map","get","RuntimeTypeError","name","TypeError","delimiter","makeTypeError","collected","trim","makeError","validate","compareTypes","a","b","TypeAlias","TypeParameter","unwrap","compareWith","FlowIntoType","AnyType","ExistentialType","MixedType","Type","typeName","Error","captureStackTrace","assert","errorMessages","getErrorMessage","key","params","replace","m","TupleType","types","checkPredicate","addError","type","collectErrors","accepts","inputTypes","isGreater","result","cyclicValidation","WeakMap","cyclicToString","WeakSet","inValidationCycle","tracked","has","startValidationCycle","set","add","endValidationCycle","delete","inToStringCycle","startToStringCycle","endToStringCycle","ArrayType","elementType","output","BooleanLiteralType","value","BooleanType","EmptyType","FlowIntoSymbol","Symbol","boundOrDefault","bound","default","recorded","withBinding","id","defaultType","flowIntoTypeParameter","typeParameter","existing","target","union","toJSON","FunctionTypeParam","optional","FunctionTypeRestParam","FunctionTypeReturn","ParentSymbol","NameRegistrySymbol","ModuleRegistrySymbol","CurrentModuleSymbol","TypeConstructorRegistrySymbol","InferrerSymbol","TypeSymbol","TypeParametersSymbol","TypePredicateRegistrySymbol","FunctionType","annotation","returnType","param","annotationParam","acceptsType","any","inputReturnType","returnTypeResult","inputParams","inputParam","rest","paramsLength","args","argsLength","empty","GeneratorType","isValid","next","return","throw","yieldType","nextType","TypeParameterApplication","typeInstances","parent","inner","hasProperty","getProperty","items","typeInstance","TypeConstructor","GenericType","impl","invariant","addConstraints","constraints","collectConstraintErrors","constraint","violation","constraintsAccept","ObjectTypeProperty","static","ObjectTypeIndexer","keyResult","valueResult","ObjectTypeCallProperty","ObjectType","properties","indexers","callProperties","exact","property","getIndexer","hasIndexer","indexer","acceptsKey","hasCallProperties","acceptsCallProperties","collectErrorsWithIndexers","collectErrorsExact","collectErrorsWithoutIndexers","acceptsWithIndexers","acceptsExact","acceptsWithoutIndexers","compareTypeCallProperties","compareTypeWithIndexers","compareTypeWithoutIndexers","body","indent","callProperty","inputCallProperties","identicalCount","j","inputCallProperty","loop","seen","indexOf","acceptsValue","inputIndexers","inputProperties","inputProperty","inputIndexer","lines","split","IntersectionType","prop","object","getPropertyIndex","mergeProperties","source","typeProp","index","hasConstraints","withDeclaration","NullLiteralType","VoidType","NullableType","NumericLiteralType","NumberType","PartialType","typeParameters","expand","ParameterizedTypeAlias","partial","getPartial","identifier","typeCreator","limit","Math","min","intersect","ParameterizedFunctionType","acceptsParams","acceptsReturn","assertParams","assertReturn","bodyCreator","function","RefinementType","StringLiteralType","JSON","stringify","StringType","SymbolLiteralType","SymbolType","ThisType","warnedInstances","TypeBox","reveal","emitWarningMessage","mixed","ref","warnedMissing","TypeReference","RevealedValue","TypeTDZ","getRevealed","container","UnionType","registerPrimitiveTypes","t","null","Object","freeze","number","boolean","string","symbol","void","existential","registerBuiltinTypeConstructors","declareTypeConstructor","Date","isNaN","getTime","Promise","futureType","keyType","valueType","keyTypes","valueTypes","findKey","Set","registerTypePredicates","setPredicate","isArray","then","TypeInferer","primitive","inferPrimitive","inferred","inferComplex","inferFunction","inferObject","fromCharCode","fn","box","inferArray","inferDict","constructor","handler","getTypeConstructor","inferTypeParameters","apply","inferInternal","numericIndexers","stringIndexers","values","item","inferredType","array","makeReactPropTypes","objectType","props","propName","componentName","makeWarningMessage","makeUnion","merged","mergeUnionTypes","aTypes","bTypes","bType","aType","makePropertyDescriptor","typeSource","propertyName","descriptor","shouldAssert","augmentExistingAccessors","propertyToAccessor","makePropertyName","getClassName","resolveType","receiver","call","safeName","className","initializer","writable","config","propertyPath","check","defineProperty","warn","originalSetter","annotateValue","Declaration","VarDeclaration","TypeDeclaration","typeAlias","addConstraint","ModuleDeclaration","moduleExports","exporting","declaration","declarations","moduleName","slice","innerContext","import","modules","module","ModuleExports","ClassDeclaration","superClass","hasSuperErrors","clearError","superClassName","ParameterizedClassDeclaration","class","ExtendsDeclaration","$DiffType","$FlowFixMeType","$KeysType","keys","literal","$ObjMapiType","mapper","applied","invoke","$ObjMapType","$PropertyType","unwrapped","$ShapeType","$SubType","$SuperType","$TupleMapType","tuple","ClassType","instanceType","prototype","isPrototypeOf","getAnnotation","matches","Number","Boolean","warnedInvalidReferences","TypeContext","mode","TypeInferrer","inferrer","infer","getPredicate","predicate","annotate","moduleRegistry","nameRegistry","var","head","handlerRegistry","instancePrototype","getPrototypeOf","parentPrototype","parentClass","typeParametersPointer","typeParam","createContext","currentModule","ModuleExportsDeclaration","tail","unshift","method","tdz","clauses","pop","pattern","tests","clause","wrappedIterator","_$PropertyType","globalContext"],"mappings":"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"}